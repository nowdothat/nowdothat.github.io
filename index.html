<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Ken" />


    
    


<meta name="description" content="vue react 前端个人总结">
<meta name="keywords" content="vue react 前端个人总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome back">
<meta property="og:url" content="https://github.com/nowdothat/vue/index.html">
<meta property="og:site_name" content="Welcome back">
<meta property="og:description" content="vue react 前端个人总结">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome back">
<meta name="twitter:description" content="vue react 前端个人总结">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">




    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Welcome back</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Ken</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Ken的个人总结</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/nowdothat/vue">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">本站内容均为个人学习总结，欢迎指正。邮箱：kencall@163.com</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Ken</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Ken</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Ken的个人总结</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-vueVirtualDom" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/03/vueVirtualDom/" class="article-date">
      <time datetime="2020-03-03T13:49:36.415Z" itemprop="datePublished">2020-03-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="virtual-dom-简介"><a href="#virtual-dom-简介" class="headerlink" title="virtual dom 简介"></a>virtual dom 简介</h1><p>当我们在用前端三大框架的时候，最常听的词汇便是 虚拟dom (virtual Dom). 本着不能知其然而不知其所以然的原则，我们来好好研究下，什么是 virtual dom</p>
<h1 id="Vue-的-virtual-dom-的生成"><a href="#Vue-的-virtual-dom-的生成" class="headerlink" title="Vue 的 virtual dom 的生成"></a>Vue 的 virtual dom 的生成</h1><p>一、将模板解析成AST</p>
<p>二、优化AST树，主要是标记静态节点</p>
<p>三、使用AST生成渲染函数</p>
<p>看下面cli例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;some text&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="comment">// App.vue</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>解释： 这是一个 vue-cli 常见的模板。我们可以得到哪些信息： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> App如果要生成 virtual dom, 生成 ast 树</span><br><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">"div"</span></span><br><span class="line">  parent: <span class="literal">undefined</span>,</span><br><span class="line">  attrsList: [],</span><br><span class="line">  attrsMap: &#123;&#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    type: <span class="number">2</span>,</span><br><span class="line">    text: <span class="string">"some"</span>,</span><br><span class="line">    <span class="keyword">static</span>: <span class="literal">false</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 优化 ast 树，并进行标记，如果不进行标记，就会造成渲染缓慢，出错等问题</span><br><span class="line">大家可以使用同 key 的方式进行试验</span><br><span class="line"><span class="number">3.</span> 使用js 创建node 并渲染</span><br><span class="line">  render (createElement, context) &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(&#123;<span class="built_in">String</span> | <span class="built_in">Object</span> | <span class="built_in">Function</span>&#125;, &#123;<span class="built_in">Object</span>&#125; | &#123;<span class="built_in">String</span> | <span class="built_in">Array</span>&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>
<h1 id="vnode-的规律"><a href="#vnode-的规律" class="headerlink" title="vnode 的规律"></a>vnode 的规律</h1><p>Vnodes are re-recreated on each render, but the HTML Elements that they reference are re-used - whenever possible<br>这句话其实是很重要的, Vue 想尽办法帮我们提升性能，所以我们就需要用 key 值进行区分渲染, 这个可以联系上面提到的 生成规律第二条</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虚拟dom 没那么高大上，也没想象中的快速。其本质就是 js 的 createElement 方法。 因为对于 浏览器而言，每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。 因为有大量地创建节点, 要更高效地区分渲染,就是 diff 算法产生的缘由。虚拟dom先讲到这里，多说无益，不如动手。欢迎通过 <a href="mailto:kencall@163.com" target="_blank" rel="noopener">kencall@163.com</a> 联系我</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-树表互转" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/29/树表互转/" class="article-date">
      <time datetime="2019-12-29T06:30:35.348Z" itemprop="datePublished">2019-12-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/29/树表互转/">树表互转</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="树转表"><a href="#树转表" class="headerlink" title="树转表"></a>树转表</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeData2tableData</span>(<span class="params">td = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> td.reduce(</span><br><span class="line">    (acc, &#123; id, pid, children, label &#125;) =&gt; </span><br><span class="line">      [...acc, ...treeData2tableData(children), &#123; id, pid, label &#125;],</span><br><span class="line">      []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">      id: <span class="string">'1'</span>, <span class="attr">pid</span>: <span class="literal">null</span>, <span class="attr">label</span>: <span class="string">'1'</span>,</span><br><span class="line">      children: [</span><br><span class="line">          &#123;</span><br><span class="line">              id: <span class="string">'1-1'</span>, <span class="attr">pid</span>: <span class="string">'1'</span>, <span class="attr">label</span>: <span class="string">'1-1'</span>,</span><br><span class="line">              children: [</span><br><span class="line">                  &#123;</span><br><span class="line">                      id: <span class="string">'1-1-1'</span>, <span class="attr">pid</span>: <span class="string">'1-1'</span>, <span class="attr">label</span>: <span class="string">'1-1-1'</span>,</span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              id: <span class="string">'1-2'</span>, <span class="attr">pid</span>: <span class="string">'1'</span>, <span class="attr">label</span>: <span class="string">'1-2'</span></span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      id: <span class="string">'2'</span>, <span class="attr">pid</span>: <span class="literal">null</span>, <span class="attr">label</span>: <span class="string">'2'</span>,</span><br><span class="line">      children: [</span><br><span class="line">          &#123;</span><br><span class="line">              id: <span class="string">'2-1'</span>, <span class="attr">pid</span>: <span class="string">'2'</span>, <span class="attr">label</span>: <span class="string">'2-1'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              id: <span class="string">'2-2'</span>, <span class="attr">pid</span>: <span class="string">'2'</span>, <span class="attr">label</span>: <span class="string">'2-2'</span></span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> cc = treeData2tableData(treeData)</span><br><span class="line"><span class="built_in">console</span>.log(cc)</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>首选设置函数参数的默认值,这是为了解决 children 为空的情况</p>
</li>
<li><p>结构必要的 key 值, 进行循环 children</p>
</li>
<li><p>递归分析 : </p>
<ol>
<li>children 进行函数执行，初始值还是为 [], 所以解构为 <ol>
<li>id: ‘1-1’, pid: ‘1’, label: ‘1-1’, children: []</li>
</ol>
</li>
<li>继续执行 …treeData2tableData(children) 函数</li>
<li>解构为 id: ‘1-1-1’, pid: ‘1-1’, label: ‘1-1-1’ …</li>
<li>继续执行 …treeData2tableData(children) ， 因为为 undefined, 所以用 [] 进行执行函数</li>
<li>回到堆地址，继续执行 解构 [{id, pid, label}]</li>
<li>输出 [{id: ‘1-1-1’, pid: ‘1-1’, label: ‘1-1-1’}]</li>
</ol>
</li>
<li><p>继续执行 reduce 函数, 因为上一次返回的是 [{id: ‘1-1-1’, pid: ‘1-1’, label: ‘1-1-1’}],将其压入堆，找到上一次起始点</p>
<ol>
<li><p>找到上一次起始点为: {id: ‘1-1’, pid: ‘1’, label: ‘1-1’}, 根据 reduce 的特性, acc 的值为 :<br>  [{id: ‘1-1-1’, pid: ‘1-1’, label: ‘1-1-1’},{id: ‘1-1’, pid: ‘1’, label: ‘1-1’}]</p>
</li>
<li><p>所以下一个要执行的对象就为 {id: ‘1-2’, pid: ‘1’, label: ‘1-2’}了, 执行.. 解构 …， 数组为空…</p>
</li>
<li><p>return 解构后的内容:<br>  [{id: “1-1-1”, pid: “1-1”, label: “1-1-1”},{id: “1-1”, pid: “1”, label: “1-1”},{id: “1-2”, pid: “1”, label: “1-2”}]</p>
</li>
<li><p>继续 执行 acc …..</p>
</li>
</ol>
</li>
</ol>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul>
<li>首先需要 了解 reduce 的特性， 将参数里的内容依次执行一遍函数，如果传入初始值，那么 索引将从 0 开始，否则从 1 开始</li>
<li>注意处理 为空 的情况， 当参数为空时，进行堆地址回归, 返回 reduce 计算</li>
</ul>
<h1 id="表转树"><a href="#表转树" class="headerlink" title="表转树"></a>表转树</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tableData2treeData</span>(<span class="params">td = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">const</span> rest = [...td]</span><br><span class="line">  <span class="keyword">const</span> ret = []</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> originItem = rest.shift()</span><br><span class="line">    <span class="keyword">const</span> &#123; id, pid, ...restProps &#125; = originItem</span><br><span class="line">    <span class="keyword">const</span> item = &#123;id, pid, ...restProps&#125;</span><br><span class="line">    <span class="keyword">const</span> target = cache.get(pid)</span><br><span class="line">    <span class="keyword">if</span>(pid === <span class="literal">null</span>) &#123;</span><br><span class="line">      ret.push(item)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target)&#123;</span><br><span class="line">      (target.children || (target.children = [])).push(item)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rest.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    cache.set(id, item);</span><br><span class="line">  &#125; <span class="keyword">while</span> (rest.length);</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tableData = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">pid</span>: <span class="literal">null</span>, <span class="attr">label</span>: <span class="string">'1'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'1-1'</span>, <span class="attr">pid</span>: <span class="string">'1'</span>, <span class="attr">label</span>: <span class="string">'1-1'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'1-1-1'</span>, <span class="attr">pid</span>: <span class="string">'1-1'</span>, <span class="attr">label</span>: <span class="string">'1-1-1'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'1-2'</span>, <span class="attr">pid</span>: <span class="string">'1'</span>, <span class="attr">label</span>: <span class="string">'1-2'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">pid</span>: <span class="literal">null</span>, <span class="attr">label</span>: <span class="string">'2'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'2-1'</span>, <span class="attr">pid</span>: <span class="string">'2'</span>, <span class="attr">label</span>: <span class="string">'2-1'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'2-2'</span>, <span class="attr">pid</span>: <span class="string">'2'</span>, <span class="attr">label</span>: <span class="string">'2-2'</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = tableData2treeData(tableData)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>首先观察数据结构:</p>
<p>  1.1 顶级元素的 id为 1 , 2, pid 为 null</p>
<p>  1.2 子级的 pid 为 父级的 id</p>
<p>  1.3 孙级的 pid 为 子级的 id </p>
<p>  1.4 整个数组为 顶级元素一整个对象，里面 children 无限嵌套  </p>
</li>
<li><p>函数分析</p>
<p>  2.1 这里使用 Map 对象  Map对象与 Object 类似,可自由选择 : Map 在涉及频繁增删键值对的场景下会有些性能优势</p>
<p>  2.2 如果 pid 为顶级元素 null, 则直接 push 进行 ret 里</p>
<p>  2.3 如果 子级的 pid === 父级 id, 判断是否存在 children，否则定义 [] 进行 push</p>
<p>  2.4 循环拿取 判断 push 进不同的 item 里面</p>
<p>  2.5 返回 ret</p>
</li>
</ol>
<h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><ul>
<li>学习使用 Map 对象</li>
</ul>
<p>​        </p>
<p>​          </p>
<p>​          </p>
<p>​          </p>
<p>​          </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git实用技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/25/git实用技巧/" class="article-date">
      <time datetime="2019-11-25T12:43:14.832Z" itemprop="datePublished">2019-11-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/git实用技巧/">git 实用技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h1><p>git 是一个分布式版本控制系统,维护的就是一个commitID树，分别保存着不同状态下的代码。 所以你对代码的任何修改，最终都会保存在本地的 .git 文件夹下</p>
<h2 id="新增分支"><a href="#新增分支" class="headerlink" title="新增分支"></a>新增分支</h2><p>git checkout -b newBranch<br>git push origin newBranch</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>// 删除本地分支，如果本地还有未合并的代码，则不能删除<br>git branch -d oldBranch<br>// 强制删除本地分支<br>git branch -D oldBranch<br>// 删除远程分支<br>git push origin -d oldBranch</p>
<h2 id="修改未-push-的-commit-信息"><a href="#修改未-push-的-commit-信息" class="headerlink" title="修改未 push 的 commit 信息"></a>修改未 push 的 commit 信息</h2><p><code>git commit --amend</code> 可以对上一次的提交做修改</p>
<h2 id="添加某一文件全部内容"><a href="#添加某一文件全部内容" class="headerlink" title="添加某一文件全部内容"></a>添加某一文件全部内容</h2><p><code>git add header-footer/xx/pc</code><br><code>git add file/xx</code></p>
<h2 id="取消删除跟踪文件"><a href="#取消删除跟踪文件" class="headerlink" title="取消删除跟踪文件"></a>取消删除跟踪文件</h2><p><code>git checkout .</code> &amp;&amp; <code>git clean -xdf</code>    ： 请勿随便使用  git clean -xdf</p>
<h2 id="取消删除最后一个提交-更改"><a href="#取消删除最后一个提交-更改" class="headerlink" title="取消删除最后一个提交/更改"></a>取消删除最后一个提交/更改</h2><p><code>git reset HEAD~1</code>   : 此命令将恢复/删除最后一个提交/更改，然后可以再次 pull 再推送,可用其来解决冲突（保存文件，执行命令，git pull ， 放置文件）</p>
<h2 id="回滚记录"><a href="#回滚记录" class="headerlink" title="回滚记录"></a>回滚记录</h2><p>// 会将提交记录回滚，代码不回滚，用来合并 commit<br>git reset abc123</p>
<p>// 会将提交记录和代码全部回滚<br>git reset –hard abc123</p>
<p>// 将部分代码文件回滚<br>git checkout – files</p>
<h2 id="stash-储藏"><a href="#stash-储藏" class="headerlink" title="stash 储藏"></a>stash 储藏</h2><p>stash 储藏，只能保存修改，不能储藏新建文件</p>
<p>使用方法: </p>
<p>git stash save ‘some ‘      保存信息—可进行切换分支<br>git stash list        查看所有列表<br>git stash apply       不会删除进行恢复<br>git stash pop          恢复删除<br>git stash clear         全部删除</p>
<h2 id="合并-commit"><a href="#合并-commit" class="headerlink" title="合并 commit"></a>合并 commit</h2><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><ol>
<li>git rebase -i commitId (这个 commitid 是跟随之后的id, 也就是 合并的分支的前一个分支–  分支 123 ，那么久是git log 的 第三个 commitid)</li>
<li>然后修改下方的 id pick 为 squash</li>
<li>删除老的commit 信息， 输入新的 commit 信息</li>
<li>:wq  over</li>
</ol>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>使用 git log 找到起始 commitID<br>git reset commitID，切记不要用 –hard 参数<br>重新 git add &amp;&amp; git commit<br>git push -f origin branchName，因为会有冲突，所以需要强制覆盖远端分支，请务必谨慎。<br>合并到 master 中，然后更新远端 master。</p>
<h2 id="reflog-找回丢失的提交"><a href="#reflog-找回丢失的提交" class="headerlink" title="reflog 找回丢失的提交"></a>reflog 找回丢失的提交</h2><p>变基时干掉过的某次提交，你只要在本地工作副本中提交过，那么，提交就会被添加到引用日志 <code>reflog</code> 中，你依然可以通过 <code>git reflog</code> 显示当前分支的所有活动的列表<br>运行：</p>
<ol>
<li>git reflog</li>
<li>git checkout <code>想回到的地方</code></li>
<li>复制信息</li>
<li>git checkout HEAD</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-observerDesign" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/27/observerDesign/" class="article-date">
      <time datetime="2019-07-27T14:06:05.471Z" itemprop="datePublished">2019-07-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/27/observerDesign/">js-Observer pattern</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>前言: 如有错误和遗漏，欢迎通过<a href="mailto:kencall@163.com" target="_blank" rel="noopener">kencall@163.com</a>联系我</p>
<h1 id="Observer-JavaScript-Design-Pattern"><a href="#Observer-JavaScript-Design-Pattern" class="headerlink" title="Observer JavaScript Design Pattern"></a>Observer JavaScript Design Pattern</h1><p>观察者模式Observer是一种设计模式，其中，一个对象，称为subject维持一系列依赖于它（观察者）的对象，将有关状态的任何变更自动通知给它们。</p>
<p>网上很多人将观察者模式与发布订阅模式（Publish/Subscribe）进行混淆。它们之间确实有很多相同点，但是在设计上还是有很大不同。</p>
<p>ok,废话不多说。看javaScript设计模式中的代码:</p>
<h2 id="构建Observer的CRUD"><a href="#构建Observer的CRUD" class="headerlink" title="构建Observer的CRUD"></a>构建Observer的CRUD</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = []</span><br><span class="line">&#125;</span><br><span class="line">ObserverList.prototype.Add = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList.push(obj)</span><br><span class="line">&#125;</span><br><span class="line">ObserverList.prototype.Empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = []</span><br><span class="line">&#125;</span><br><span class="line">ObserverList.prototype.Count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length</span><br><span class="line">&#125;</span><br><span class="line">ObserverList.prototype.Get = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">-1</span> &amp;&amp; index &lt; <span class="keyword">this</span>.observerList.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.observerList[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增observer的位置不是最后就是最前</span></span><br><span class="line">ObserverList.prototype.Insert = <span class="function"><span class="keyword">function</span>(<span class="params">obj,index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pointer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.unshift(obj)</span><br><span class="line">        pointer = index;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.observerList.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.push(obj)</span><br><span class="line">        pointer = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找寻observer的具体索引</span></span><br><span class="line">ObserverList.prototype.IndexOf = <span class="function"><span class="keyword">function</span>(<span class="params">obj, startIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = startIndex, pointer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt; <span class="keyword">this</span>.observerList.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.observerList[i] === obj) &#123;</span><br><span class="line">            pointer = i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointer</span><br><span class="line">&#125;</span><br><span class="line">ObserverList.prototype.RemoveIndexAt = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.shift()</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.observerList.length<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.pop()</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> reset = <span class="keyword">this</span>.observerList.slice(index + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">this</span>.observerList.length = index &lt; <span class="number">0</span> ? <span class="keyword">this</span>.observerList.length + index : index;</span><br><span class="line">      <span class="keyword">this</span>.observerList = <span class="keyword">this</span>.observerList.concat(reset)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个赋值方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, extension</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        extension[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="subject对observer的CRUD"><a href="#subject对observer的CRUD" class="headerlink" title="subject对observer的CRUD"></a>subject对observer的CRUD</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体动作的发出者，维护者 --用于发布信息给依赖于它的观察者对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList;</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype.AddObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.Add(observer)  </span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype.RemoveObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.RemoveIndexAt(<span class="keyword">this</span>.observers.IndexOf(observer, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype.Notify = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> observerCount = <span class="keyword">this</span>.observers.Count()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; observerCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里的Update是实例方法</span></span><br><span class="line">        <span class="keyword">this</span>.observers.Get(i).Update(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用1"><a href="#实际应用1" class="headerlink" title="实际应用1"></a>实际应用1</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"addNewObserver"</span>&gt;</span>Add New observer checkbox<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"mainCheckbox"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"observersContainer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"observerControl"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./observer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">   	<span class="keyword">var</span> controlCheckBox = <span class="built_in">document</span>.getElementById(<span class="string">'mainCheckbox'</span>),</span></span><br><span class="line"><span class="javascript">        addObserverBtn = <span class="built_in">document</span>.getElementById(<span class="string">'addNewObserver'</span>),</span></span><br><span class="line"><span class="javascript">        container = <span class="built_in">document</span>.getElementById(<span class="string">'observerContainer'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个按钮就是一个具体目标，控制发布所有信息给它的观察者</span></span></span><br><span class="line"><span class="javascript">    extend(<span class="keyword">new</span> Subject(), controlCheckbox)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 当这个具体目标点击时，会触发依赖于suject的各个观察者对象</span></span></span><br><span class="line"><span class="javascript">    controlCheckbox[<span class="string">"onclick"</span>] = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"controlCheckbox.Notify(controlCheckbox.checked)"</span>)  </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接下来定义多个基于suject的各个观察者</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.Update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 这里的方法一般会被重写,因为在这个例子中，this需要指向inputDOM本身才有意义，如果将check定义在这里的话，无法找到this,DOM本身</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">AddNewObserver</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> check = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</span></span><br><span class="line"><span class="javascript">          check.type=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="javascript">          extend(<span class="keyword">new</span> Observer(), check)</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 上面是添加一个观察者</span></span></span><br><span class="line"><span class="javascript">          check.Update = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 同步多个observer的更新方法</span></span></span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.checked = value;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// suject目标添加观察者</span></span></span><br><span class="line"><span class="undefined">          controlCheckbox.AddObserver(check)</span></span><br><span class="line"><span class="undefined">          container.appendChild(check)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里只是为了测试--新增多个观察者</span></span></span><br><span class="line"><span class="javascript">      addObserverBtn[<span class="string">"onclick"</span>] = AddNewObserver</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实际应用2"><a href="#实际应用2" class="headerlink" title="实际应用2"></a>实际应用2</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"subject"</span>&gt;</span>我是具体目标<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"observer1"</span>&gt;</span>我是观察者1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"observer2"</span>&gt;</span>我是观察者2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"observer3"</span>&gt;</span>我是观察者3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cancalObserver"</span>&gt;</span>解除第二个观察者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./observer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> subject = <span class="built_in">document</span>.getElementById(<span class="string">'subject'</span>),</span></span><br><span class="line"><span class="javascript">      observer1 = <span class="built_in">document</span>.getElementById(<span class="string">'observer1'</span>),</span></span><br><span class="line"><span class="javascript">      observer2 = <span class="built_in">document</span>.getElementById(<span class="string">'observer2'</span>),</span></span><br><span class="line"><span class="javascript">      observer3 = <span class="built_in">document</span>.getElementById(<span class="string">'observer3'</span>),</span></span><br><span class="line"><span class="javascript">      cancalObserver = <span class="built_in">document</span>.getElementById(<span class="string">'cancalObserver'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义subject</span></span></span><br><span class="line"><span class="javascript">  extend(<span class="keyword">new</span> Subject(), subject);    </span></span><br><span class="line"><span class="javascript">  subject.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 触发更新机制</span></span></span><br><span class="line"><span class="javascript">    subject.Notify(<span class="string">'明天放假一天'</span>)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义observer及其回调</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个函数的作用在于抽象，如果事件不复杂的话，也可以像下面一样，直接自定义  </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.Update= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 给suject添加observer</span></span></span><br><span class="line"><span class="undefined">  subject.AddObserver(observer1)</span></span><br><span class="line"><span class="undefined">  subject.AddObserver(observer2)</span></span><br><span class="line"><span class="undefined">  subject.AddObserver(observer3)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  observer1.Update= <span class="function"><span class="keyword">function</span>(<span class="params">acceptInfo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(acceptInfo+<span class="string">'-- 好的，观察者一收到'</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  observer2.Update= <span class="function"><span class="keyword">function</span>(<span class="params">acceptInfo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(acceptInfo+<span class="string">'-- 好的，观察者二收到'</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  observer3.Update= <span class="function"><span class="keyword">function</span>(<span class="params">acceptInfo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(acceptInfo+<span class="string">'-- 好的，观察者三收到'</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 解除某一观察者</span></span></span><br><span class="line"><span class="javascript">  cancalObserver.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    subject.RemoveObserver(observer2),</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'观察者二解除观察----》》》'</span>)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么最后：什么是观察者模式—&gt; : </p>
<ol>
<li>首先要定义一个subject目标源，监听某一事件-&gt;触发subject.Notify(-&gt;触发observer.Update())</li>
<li>定义具体的observer,考虑事件是否可抽象-&gt;(subject发布信息后，观察者具体需要做的事情)</li>
<li>给subject添加具体的observer</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>The <strong>observer pattern</strong> is a software design pattern in which an object, called the <strong>subject</strong>, maintains a list of its dependents, called <strong>observers</strong>, and notifies them automatically of any state changes, usually by calling one of their methods.</p>
<p>subject触发某一事件的时候，会自动发布事件给它的观察者。这个观察者不需要监听某一事件.但是suject必须显示地添加其观察者</p>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>In ‘Publisher-Subscriber’ pattern, senders of messages, called <strong>publishers</strong>, do not program the messages to be sent directly to specific receivers, called <strong>subscribers.</strong></p>
<p>而发布者不必知道订阅者是谁，只需要将事件发布到一个“中间件”，由中间件去处理订阅者的不同需求</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/26/TCP/" class="article-date">
      <time datetime="2019-06-26T14:52:14.126Z" itemprop="datePublished">2019-06-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/26/TCP/">TCP/IP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="什么是TCP-IP协议"><a href="#什么是TCP-IP协议" class="headerlink" title="什么是TCP/IP协议"></a>什么是TCP/IP协议</h1><ul>
<li><p>TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是TCP和IP。因此，大部分网络管理员称整个协议族为“TCP/IP”。</p>
</li>
<li><p>TCP/IP的迅速流行要归功于它的低成本、可在不同的平台间进行通信的能力和它开放的特性。“开放”的意思是软件开发人员可以自由地使用和修改TCP/IP的核心协议。TCP/IP是Internet实际采用的标准。UNIX和Linux一直都使用TCP/IP，Windows网络操作系统也以TCP/IP作为默认的协议。</p>
</li>
</ul>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><ul>
<li>链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_level.png" alt="snipaste_level"></p>
<ol>
<li>第一层：网络接口层：TCP/IP协议的最低一层，对实际的网络媒体的管理，包括操作系统中的设备驱动程序和计算机对应的网络接口</li>
<li>第二层：网络层：该层负责相同或不同网络中计算机之间的通信主要处理数据包和路由。数据包是网络传输的最小数据单位。通过某条传输路线将数据包传给对方。IP协议,ICMP协议，IGMP协议。在IP层中，ARP协议用于将IP地址转换成物理地址，ICMP协议用于报告差错和传送控制信息。IP协议在TCP/IP协议组中处于核心地位。</li>
<li>第三层：传输层：提供TCP(传输控制协议)，UDP（用户数据报协议）两个协议，主要功能是数据格式化、数据确认和丢失重传等。</li>
<li>第四层：应用层：TCP/IP协议的<strong>应用层</strong>相当于OSI模型的<strong>会话层、表示层和应用层</strong>，FTP(文件传输协议)，DNS（域名系统），HTTP协议，Telnet（网络远程访问协议）</li>
</ol>
<h1 id="主讲第三层的TCP传输控制协议"><a href="#主讲第三层的TCP传输控制协议" class="headerlink" title="主讲第三层的TCP传输控制协议"></a>主讲第三层的TCP传输控制协议</h1><p><code>简述</code></p>
<p>TCP将包排序并进行错误检查，同时实现<a href="https://baike.baidu.com/item/%E8%99%9A%E7%94%B5%E8%B7%AF/1609903" target="_blank" rel="noopener">虚电路</a>间的连接。TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。</p>
<p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p><code>tcp包结构</code></p>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_tcpdata.png" alt="snipaste_tcpdata"></p>
<p>阮一峰老师的博客：以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）</p>
<p>我的理解：在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500</p>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_MTUSize.png" alt="snipaste_MTUSize"></p>
<p>所以TCP包的大小：MTU字节大小1500-IP头部信息20-TCP头长度20-TCP timestrap option12 = 1448Byte</p>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_TCPDataPage.png" alt="snipaste_TCPDataPage"></p>
<p>根据上面这张图，可得知：IP数据包在以太网数据包里面,TCP数据包在IP数据包里面</p>
<h3 id="tcp的序号seq"><a href="#tcp的序号seq" class="headerlink" title="tcp的序号seq"></a>tcp的序号seq</h3><p>TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收</p>
<p>当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295(二的32次方-1)之间的任意值———tcp/ip详解协议卷第18章18.2.3解释初始序列号随时间变化，每个连接有不同的初始序列号，每4ms加一</p>
<hr>
<p>在 TCP 数据报中，有一个 序列号 (Sequence Number)。如果序列号被人猜出来，就会展现出 TCP 的脆弱性。</p>
<p>如果选择合适的序列号、IP地址以及端口号，那么任何人都能伪造出一个 TCP 报文段，从而 打断 TCP 的正常连接[RFC5961]。一种抵御上述行为的方法是使初始序列号(或者临时端口 号[RFC6056])变得相对难以被猜出，而另一种方法则是加密。</p>
<p>Linux 系统采用一个相对复杂的过程来选择它的初始序列号。它采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量。随机偏移量是在连接标识(由 2 个 IP 地址与 2 个端口号构成的 4 元组，即 4 元组)的基础上利用加密散列函数得到的。散列函数的输人每隔 5 分钟就会改变一次。在 32 位的初始序列号中，最高的 8 位是一个保密的序列号，而剩余的备位则由散列函数生成。上述方法所生成的序列号很难被猜出，但依然会随着时间而逐步增加。据报告显示， Windows 系统使用了一种基于 RC4[S94] 的类似方案。</p>
<h4 id="数据包的分割"><a href="#数据包的分割" class="headerlink" title="数据包的分割"></a>数据包的分割</h4><p>那么一次性发送大量数据，就必须分成多个包。比如，一个 100000字节大小的文件/MSS最大报文长度 = TCP报文段</p>
<h3 id="tcp的确认号ack"><a href="#tcp的确认号ack" class="headerlink" title="tcp的确认号ack"></a>tcp的确认号ack</h3><ol>
<li><p>发送数据： 服务器向客户端发送一个带有数据的数据包。该数据包中的序列号和确认号与建立连接的第三步的数据包的序列号和确认号相同</p>
</li>
<li><p>确认收到: 客户端收到该数据包，向服务器发送一个确认数据包。该数据包中，序列号是为上一个数据包中的确认号值</p>
<p>这个确认号为服务器发送的上一个数据包中的序列号+该数据包中所带的数据的大小</p>
<p>回复确认收到的ack = 收到了序列号 + 数据的大小（同时也表示下一次期望收到的序号）</p>
</li>
</ol>
<ul>
<li>主机A接收主机b 假设编号为0-535的字节（意味着mss值为535byte）,主机A会在发往主机B的报文段的确认号字段ack上填上536</li>
<li><p>每一个包都可以得到seq和ack, 接收方就可以根据编号进行排序（按照什么顺序进行还原原始文件）或者丢弃。发送方根据ack判断接收方是否收到了指定包，判断是否需要重传</p>
<p> ​——————这样就保证了数据通信的完整性和可靠性，防止丢包</p>
</li>
</ul>
<h1 id="tcp头字段"><a href="#tcp头字段" class="headerlink" title="tcp头字段"></a>tcp头字段</h1><table>
<thead>
<tr>
<th>seq</th>
<th>序号 32位标识数据段在已发送的数据流中的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>ack</td>
<td>确认号,验证是否已被接收</td>
</tr>
<tr>
<td>SYN</td>
<td>为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步</td>
</tr>
<tr>
<td>ACK</td>
<td>为1表示确认号字段有效</td>
</tr>
<tr>
<td>FIN</td>
<td>为1表示发送方没有数据要传输了，要求释放连接。</td>
</tr>
<tr>
<td>PSH</td>
<td>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</td>
</tr>
<tr>
<td>RST</td>
<td>为1表示出现严重差错。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求</td>
</tr>
</tbody>
</table>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数<strong>A</strong>。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为<strong>A+1</strong>，SYN/ACK包本身又有一个随机产生的序号<strong>B</strong>。</li>
<li>最后，客户端再发送一个<a href="https://zh.wikipedia.org/wiki/%E7%A2%BA%E8%AA%8D%E8%A8%8A%E6%81%AF" target="_blank" rel="noopener">ACK</a>。此时包的序号被设定为<strong>A+1</strong>，而ACK的确认码则为<strong>B+1</strong>。当服务端收到这个ACK的时候，就完成了三次握手，并进入了连接创建状态。</li>
<li>这里的+1是根据发送的length来决定的</li>
</ol>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_startConnect.png" alt="snipaste_startConnect"></p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>服务端发送的seq和ack必须和第三次客户端回传的seq和ack保持一致</p>
<p>客户端确认收到：seq = 服务端的ack  ack = 服务端的seq+该数据包中所带数据的大小（同时也表示下一次期望收到的序号）</p>
<p>服务器回应：seq = 客户端回传的ack  ack = 客户端回传的seq+客户端回传的length</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>在这个过程中连接的每一侧都独立地被终止。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。所以本质是二次，因为是双工原因，所以有4次挥手</p>
<p><code>首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接</code></p>
<p>注意： 首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接</p>
<p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_stopConnect.png" alt="snipaste_stopConnect"></p>
<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p><img src="/nowdothat/vue/2019/06/26/TCP/snipaste_summanry.png" alt="snipaste_summanry"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入Vue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/13/深入Vue/" class="article-date">
      <time datetime="2019-06-12T23:31:29.050Z" itemprop="datePublished">2019-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/深入Vue/">深入Vue</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="构建Vue实例"><a href="#构建Vue实例" class="headerlink" title="构建Vue实例"></a>构建Vue实例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 手动构建元素</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue/dist/vue.js'</span> <span class="comment">//注意，需要制定vue运行版本</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: div,</span><br><span class="line">  template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">如果在<span class="keyword">new</span>实例时，没有指定el，可以进行,跟上面一样的效果</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">app.$mount(<span class="string">'#root'</span>)</span><br><span class="line"><span class="comment">// 当执行的时候，模板文件会将el的节点进行替换</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 通过html-webpack-plugin插件进行生成插入</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./index.html'</span></span><br><span class="line">  &#125;),</span><br></pre></td></tr></table></figure>
<h1 id="Vue实例属性"><a href="#Vue实例属性" class="headerlink" title="Vue实例属性"></a>Vue实例属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> 			 el: div,</span><br><span class="line">  			 template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">		   &#125;)</span><br><span class="line">该app常量就是Vue实例自动绑定的<span class="keyword">this</span>,意味着下面的app.$属性，即为<span class="keyword">this</span>.$属性</span><br></pre></td></tr></table></figure>
<ul>
<li>app.$data data()定义的值</li>
<li>app.$props 组件传值</li>
<li>app.$el ATS抽象树</li>
<li>app.$options  合成过后的属性-即为整个实例</li>
<li>app.$options.render =  (h)  =&gt; {return h(‘div’, {}, ‘new render content’ )}  当页面数据进行更新的时候，会触发这个函数</li>
<li>app.$root  就是app本身</li>
<li>app.$children  类似于react的props.children <item><code>&lt;div&gt;这个div就是children值&lt;/div&gt;</code> </item></li>
<li>app.$parent    查找父组件 app.$ $parent.$options.name    一般配合extend使用</li>
<li>app.$slots</li>
<li>app.$scopedSlots</li>
<li>app.$refs  ref指定的元素数组集合，可以进行操纵DOM</li>
<li>app.$isServer  服务端渲染用</li>
<li>app.$on(‘事件名’, (子组件params1, paramsTwo) =&gt; {})</li>
<li>app.$emit(‘事件名’, 传给父组件参数1， 参数2)</li>
<li>app.$set(app.obj, ‘a属性’, 修改的值)</li>
<li>app.$delete(app.obj, 要删除的属性)</li>
<li>app.$forceUpdate() 强制更新视图，与react类似</li>
<li>app.$destroy() 销毁实例，一般不会去做</li>
</ul>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>如果使用watch方法，没有控制好，有可能会造成内存溢出，所以，在某些情况下可能需要移除watch</p>
<p>watch和computed都不要去修改监听的值，否则会造成无限循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unWatch = <span class="keyword">this</span>.$watch(<span class="string">'text'</span>, (newVal,oldVal) =&gt; &#123;&#125;)</span><br><span class="line">unWatch() 注销watch</span><br><span class="line"></span><br><span class="line">如果使用Vue模板文件，可以这样写</span><br><span class="line">watch: &#123;</span><br><span class="line">  text (newVal,oldVal) &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">模板文件的watch，会被编译成handler方法，如果我们手动写handler方法，可以使用immediate：<span class="literal">true</span>使watch立即执行</span><br><span class="line">watch: &#123;</span><br><span class="line">  text: &#123;</span><br><span class="line">    handler (newVal, oldVal) &#123;</span><br><span class="line">      <span class="keyword">do</span> some thing</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    deep: <span class="literal">true</span> <span class="comment">// 默认为false 是否watch 对象键值 -遍历对象，消耗性能，解决办法监听'text.a'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Vue跟react的更新生命周期形式很类型, Vue：beforeUpdate | update — React: componentWillUpdate | compoentDidUpdate。不同的是，react在执行componentDidUpdate前，会先执行render()方法,Vue没有</p>
<ul>
<li>vue跟react都有强制更新视图的操作this.forceUpdate()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue编译我们的template模板，最后为render方法输出。render方法在mounted前进行调用，所以beforeMount()生命周期<span class="keyword">this</span>-不指向Vue实例</span><br><span class="line">render (h) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'render error'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">renderError (h, err) &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, &#123;&#125;, err.stack)</span><br><span class="line">  <span class="comment">// 这个不会捕获子组件的报错，只能在生产环境下使用</span></span><br><span class="line">&#125;,</span><br><span class="line">errorCaptured (h, err) &#123;&#125;</span><br><span class="line"><span class="comment">//这个会向上冒泡，并能在正式环境中使用</span></span><br></pre></td></tr></table></figure>
<h3 id="原生指令"><a href="#原生指令" class="headerlink" title="原生指令"></a>原生指令</h3><ul>
<li>v-model.number  转换字符串为数字</li>
<li>v-model.trim  去除空格</li>
<li>v-model.lazy    change的时候才进行改变</li>
<li>v-pre   不进行解析表达式，页面展示模板字符串</li>
<li>v-once 只绑定一次</li>
<li>v-cloak 使用场景少</li>
</ul>
<h3 id="props严格验证"><a href="#props严格验证" class="headerlink" title="props严格验证"></a>props严格验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  active: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    validator (value) &#123;</span><br><span class="line">    <span class="comment">// value就是传进来的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'boolean'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>vue的双向绑定和react基本一致，都是采用e.target.value的方式进行绑定</p>
<p>子组件=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; @input=&quot;handleInput&quot;&gt;</span><br><span class="line"></span><br><span class="line">function handleInput(e) &#123;</span><br><span class="line">	this.$emit(&apos;input&apos;, e.target.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件 = </p>
<p>value=”value” @input=”value = arguments[0]”</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义一个组件</span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  	&lt;div&gt;</span></span><br><span class="line"><span class="string">		&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">		&lt;slot name="body"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">	&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">调用组件</span><br><span class="line">&lt;comp-one&gt;</span><br><span class="line">	&lt;span&gt;show the slot&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span slot="body"&gt;show the bodyName slot&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/comp-one&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作用域插槽的概念</span><br><span class="line">	一般来讲，组件内部的变量是根据当前引用组件的变量来变化的</span><br><span class="line">    如果使用了slot-scope，就可以使用当前组件内部定义的变量+引用组件的变量</span><br><span class="line">定义组件</span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  	&lt;div&gt;</span></span><br><span class="line"><span class="string">		&lt;slot value="456"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">	&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">引用组件-通过props.定义值来调用，引用组件的值可以直接写</span><br><span class="line">&lt;comp-one&gt;</span><br><span class="line">  &lt;span slot-scope=<span class="string">"props"</span>&gt;&#123;&#123;props.value&#125;&#125;&#123;&#123;currentData&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>comp-one&gt;</span><br></pre></td></tr></table></figure>
<h3 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">爷爷级组件</span><br><span class="line">provide() &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, <span class="string">'value'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.value,</span><br><span class="line">    enumerable: <span class="literal">true</span> <span class="comment">//提供可读</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    yeye: <span class="keyword">this</span>,</span><br><span class="line">    value: <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">孙级组件</span><br><span class="line">inject: [<span class="string">'yeye'</span>, <span class="string">'data'</span>]</span><br><span class="line">调用-- <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;data.value&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">这种方法适用于简单的组件级通信，解决只能父子组件通信的问题。如果交互的数据量比较多，可以采用vuex通信</span><br></pre></td></tr></table></figure>
<h3 id="render方法"><a href="#render方法" class="headerlink" title="render方法"></a>render方法</h3><p>首先我们需要明白：构建Vue组件有三种方式 ：<code>template</code> / <code>renderFunction</code> / <code>js</code></p>
<p>在mounted生命周期前调用render方法，默认传入this.$createElement方法，该方法可以创建一个vnode节点，用来跟DOM节点进行对比</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">模板文件为</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;comp-one ref="comp"&gt;</span></span><br><span class="line"><span class="string">  	&lt;span ref="span"&gt;&#123;&#123;value&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/comp-one&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">---------------------转换成render方法---------------------</span><br><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">  	<span class="string">'comp-one'</span>,</span><br><span class="line">  	&#123;</span><br><span class="line">      ref: <span class="string">'comp'</span></span><br><span class="line">  	&#125;,</span><br><span class="line">  	[</span><br><span class="line">      createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">        ref: <span class="string">'span'</span></span><br><span class="line">      &#125;, <span class="keyword">this</span>.value)</span><br><span class="line">  	]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">注意点： 加入子节点的的时候，需要使用数组createdElement(<span class="string">'节点名称'</span>,&#123;属性&#125;, 值)</span><br><span class="line">如果是slot,则是</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">  	&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">render(createdElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createdElement(<span class="string">'div'</span>, &#123;<span class="attr">style</span>: <span class="keyword">this</span>.style&#125;, <span class="keyword">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="事件的渲染"><a href="#事件的渲染" class="headerlink" title="事件的渲染"></a>事件的渲染</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">------------------组件内部------------------</span><br><span class="line">props: [<span class="string">'props1'</span>],</span><br><span class="line">name: <span class="string">'comp'</span>,</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">  	&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">--------------------转换render--------------</span><br><span class="line">render(createdElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createdElement(<span class="string">'div'</span>, </span><br><span class="line">     &#123;</span><br><span class="line">    	style: <span class="keyword">this</span>.style,</span><br><span class="line">    	on: &#123;</span><br><span class="line">          click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">this</span>.$emit(<span class="string">'click'</span>)&#125;<span class="comment">// 注意与nativeOn的区别</span></span><br><span class="line">    	&#125;</span><br><span class="line">  	 &#125;, [</span><br><span class="line">		<span class="keyword">this</span>.$slots.default,</span><br><span class="line">    	<span class="keyword">this</span>.props1</span><br><span class="line">	 ])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">--------------------------引用组件-------------------------</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick() &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">  	<span class="string">'comp-one'</span>,</span><br><span class="line">  	&#123;</span><br><span class="line">      ref: <span class="string">'comp'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        props1: <span class="keyword">this</span>.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.handeleClick</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;,</span><br><span class="line">  	[</span><br><span class="line">      createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">        ref: <span class="string">'span'</span></span><br><span class="line">      &#125;, <span class="keyword">this</span>.value)</span><br><span class="line">  	]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果采用nativeOn: &#123;</span><br><span class="line">  click: <span class="keyword">this</span>.handleClick<span class="comment">//是将事件直接绑定在根节点上，不需要采用on/emit的方式</span></span><br><span class="line">  												<span class="comment">//意味着组件上不需要定义on事件就可以直接触发了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="具名插槽的render方式"><a href="#具名插槽的render方式" class="headerlink" title="具名插槽的render方式"></a>具名插槽的render方式</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通插槽使用<span class="keyword">this</span>.$slots.default生成一个vnode节点</span><br><span class="line">具名插槽使用<span class="keyword">this</span>.$slots.名称生成vnode节点</span><br><span class="line">------定义组件------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.$slots.header)</span><br><span class="line">&#125;</span><br><span class="line">------引用组件-------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, [</span><br><span class="line">    createElement(<span class="string">'span'</span>, &#123;<span class="attr">slot</span>: <span class="string">'header'</span>&#125;,<span class="string">'123'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="添加原生DOM属性"><a href="#添加原生DOM属性" class="headerlink" title="添加原生DOM属性"></a>添加原生DOM属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------引用组件-------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, [</span><br><span class="line">    createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">      slot: <span class="string">'header'</span>,</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        innerHTML: <span class="string">'&lt;span&gt;原生DOM添加了元素节点&lt;/span&gt;'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: <span class="string">'test-id'</span><span class="comment">//给原生DOM上添加了id属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">'123'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-react入门指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/02/react入门指南/" class="article-date">
      <time datetime="2019-06-02T14:39:13.463Z" itemprop="datePublished">2019-06-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/02/react入门指南/">React基础个人总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h1><p>React 应用程序的组成部分： 元素和组件</p>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><h3 id="JSX语法介绍"><a href="#JSX语法介绍" class="headerlink" title="JSX语法介绍"></a>JSX语法介绍</h3><p>我们建议<a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">使用 JSX</a> 来编写你的 UI 组件。每个 JSX 元素都是调用 <a href="https://react.docschina.org/docs/react-api.html#createelement" target="_blank" rel="noopener"><code>React.createElement()</code></a> 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用以下方法。</p>
<ul>
<li><a href="https://react.docschina.org/docs/react-api.html#createelement" target="_blank" rel="noopener"><code>createElement()</code></a></li>
<li><a href="https://react.docschina.org/docs/react-api.html#createfactory" target="_blank" rel="noopener"><code>createFactory()</code></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">JSX 是JavaScript 的语法扩展，它具有 JavaScript 的全部功能。</span><br><span class="line"></span><br><span class="line">React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</span><br><span class="line"></span><br><span class="line">React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</span><br><span class="line"></span><br><span class="line">React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</span><br><span class="line"></span><br><span class="line">在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，<span class="number">2</span> + <span class="number">2</span>，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式.下面是个简单的例子</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">            我们将一个js表达式插进jsx语法中，并实现了'Harper Perez'</span></span><br><span class="line"><span class="regexp">            如果是在Vue项目中，我们可以使用computed计算属性进行这样的操作</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">  注意：我们在定义element变量的时候，使用的是()的形式。原因是：我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。</span></span><br></pre></td></tr></table></figure>
<h6 id="jsx也是一个表达式，意味着可以进行函数渲染"><a href="#jsx也是一个表达式，意味着可以进行函数渲染" class="headerlink" title="jsx也是一个表达式，意味着可以进行函数渲染"></a>jsx也是一个表达式，意味着可以进行函数渲染</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="JSX的特定属性"><a href="#JSX的特定属性" class="headerlink" title="JSX的特定属性"></a>JSX的特定属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// ""和&#123;&#125;只能同时使用一个，对于同一属性不能同时使用这2种符号</span></span><br></pre></td></tr></table></figure>
<p><strong>警告：</strong></p>
<p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
<p>例如，JSX 里的 <code>class</code> 变成了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，而 <code>tabindex</code> 则变为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p>
<h6 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h6><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const element = React.createElement(</span></span><br><span class="line"><span class="regexp">  'h1',</span></span><br><span class="line"><span class="regexp">  &#123;className: 'greeting'&#125;,</span></span><br><span class="line"><span class="regexp">  'Hello, world!'</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">-------------------------------------简化编译---------------------------------</span></span><br><span class="line"><span class="regexp">  const element = &#123;</span></span><br><span class="line"><span class="regexp">  type: 'h1',</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    className: 'greeting',</span></span><br><span class="line"><span class="regexp">    children: 'Hello, world!'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="react元素不可变性"><a href="#react元素不可变性" class="headerlink" title="react元素不可变性"></a>react元素不可变性</h3><p>React 元素是<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变对象</a>。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件也可以被定义为可被包装的函数</p>
<p>定义组件最简单的方式就是编写 JavaScript 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>
<p>你同时还可以使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 的 class</a> 来定义组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个组件在 React 里是等效的</p>
<h6 id="自定义函数组件"><a href="#自定义函数组件" class="headerlink" title="自定义函数组件"></a>自定义函数组件</h6><p>React 元素也可以是用户自定义的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br></pre></td></tr></table></figure>
<p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<p>例如，这段代码会在页面上渲染 “Hello, Sara”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br><span class="line"><span class="xml">// 分析步骤：</span></span><br><span class="line"><span class="xml">	1. 我们调用ReactDom.render()函数，并传入jsx语法变量elemnnt作为参数</span></span><br><span class="line"><span class="xml">    2. React调用Welcome组件， 并将&#123;name: 'Sara'&#125;作为props传入</span></span><br><span class="line"><span class="xml">    3. Welcome组件将 jsx对象作为返回值</span></span><br><span class="line"><span class="xml">    4. React DOM将DOM进行对比更新</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 组件名称必须以大写字母开头,React 会将以小写字母开头的组件视为原生 DOM 标签</p>
<p>​        <strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong>–类似于Vue的单向数据流，子组件不能修改父组件的传值，只能通过触发父组件的事件进行修改</p>
<p>​        所以我们只能修改组件内部的数据state，它 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。 —–对比Vue的data和props</p>
<h6 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h6><ul>
<li><p>不要直接修改state—使用setState({})</p>
<ul>
<li>构造函数是唯一可以给 <code>this.state</code> 赋值的地方</li>
</ul>
</li>
<li><p>state的更新可能是异步的</p>
<ul>
<li><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</p>
</li>
<li><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line">要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>state的更新会被合并</p>
<ul>
<li>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state</li>
<li>这就意味着：当你的state对象里面有多个值时，你多次调用setState（{someKeys:xx}）这里的对象合并是浅合并，setState方法保留了其他未被重置的属性，但是完全替换了someKyes</li>
</ul>
</li>
</ul>
<h6 id="将函数组件转换为class组件"><a href="#将函数组件转换为class组件" class="headerlink" title="将函数组件转换为class组件"></a>将函数组件转换为class组件</h6><p>———–需要注意的是，如果是通过compoent={}的形式，需要在constructor(props)进行传递</p>
<ol>
<li><p>创建一个同名的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>，并且继承于 <code>React.Component</code>。</p>
</li>
<li><p>添加一个空的 <code>render()</code> 方法。</p>
</li>
<li><p>将函数体移动到 <code>render()</code> 方法之中。</p>
</li>
<li><p>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</p>
</li>
<li><p>删除剩余的空函数声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.Component 是使用 ES6 classes 方式定义 React 组件的基类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;<span class="keyword">do</span> some thing&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>———————通过以下方式将 <code>props</code> 传递到父类的构造函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。—使用表达式</li>
</ul>
<p>一般情况下，传入没有调用的函数都会丢失this指向，解决办法是使用Function.prototype.bind()或者是使用箭头函数，亦或者是class fields进行解决</p>
<h6 id="函数传入参数"><a href="#函数传入参数" class="headerlink" title="函数传入参数"></a>函数传入参数</h6><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="循环渲染需要带key"><a href="#循环渲染需要带key" class="headerlink" title="循环渲染需要带key"></a>循环渲染需要带key</h3><p>React 支持 <code>key</code> 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素</p>
<p>Vue的key属性也是做同样的事情，进行diffing算法运算</p>
<h1 id="react-PureComponet"><a href="#react-PureComponet" class="headerlink" title="react.PureComponet"></a>react.PureComponet</h1><p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。</p>
<h1 id="需要注意的小细节"><a href="#需要注意的小细节" class="headerlink" title="需要注意的小细节"></a>需要注意的小细节</h1><ul>
<li>autoFocus一定要配合tabIndexReact </li>
<li>来使用</li>
<li>constructor要配置super使用</li>
<li>渲染的时候要使用标签的形式进行渲染</li>
<li>在组件内部的dom元素中添加事件<ul>
<li><h2 onclick="{clickFun}"></h2>



</li>
</ul>
</li>
</ul>
<h4 id="组件渲染时的this问题"><a href="#组件渲染时的this问题" class="headerlink" title="组件渲染时的this问题"></a>组件渲染时的this问题</h4><p>react 在render({this.state.xx})拿值是可以，但是在执行函数的时候却为undefined的原因？<br>—因为js是单线程事件型语言，当遇到函数或者定时器等异步操作时，会先向下执行，等事件触发，或者有空闲的时候再执行异步操作–那个时候，上下文已经丢失，所以this执行就已经丢失了<br>———–办法就是，</p>
<ol>
<li>在dom渲染的时候，手动绑定上下文{this.事件名.bind(this)}</li>
<li>使用() =&gt; {利用箭头函数的特性绑定this}</li>
</ol>
<h4 id="组件的基本生命周期"><a href="#组件的基本生命周期" class="headerlink" title="组件的基本生命周期"></a>组件的基本生命周期</h4><p>以类定义的组件，都有一样的生命周期</p>
<ul>
<li>constructor() {}</li>
<li>componentWillMount() {} //加载前，可以进行拿取数据</li>
<li>render() {}</li>
<li>componentDidMount() {} //页面加载完成</li>
<li>if（进行更新state)————–<ul>
<li>componentWillUpdate() {} // 可以进行数据的验证</li>
<li>render()</li>
<li>compoentDidUpdate()  //更新完成</li>
</ul>
</li>
</ul>
<p>有一个this.forceUpdate() –强制更新DOM    </p>
<p>shouldCompoentUpdate() {return false} —不进行更新  — 控制componentWillUpdate的执行</p>
<p>————————————————————特殊的——————————————————</p>
<p>componentWillUnmount()—-:通过非React提供的方式注册的事件，通常需要在这个方法中注销事件，以及该组件中使用的计时器，也需要在这里清除！！！</p>
<h2 id="setState的作用"><a href="#setState的作用" class="headerlink" title="setState的作用"></a>setState的作用</h2><ol>
<li>可以用来更新数据</li>
<li>会自动地调用render()</li>
</ol>
<h2 id="父子组件中遇到的问题"><a href="#父子组件中遇到的问题" class="headerlink" title="父子组件中遇到的问题"></a>父子组件中遇到的问题</h2><p>父组件调用了render方法，则子组件必定会调用render方法。子组件调用render方法，则父组件不会调用render方法</p>
<p>父组件向子组件传值，是将父组件的数据或者方法作为子组件的属性值进行传递</p>
<p>​    子组件通过this.props.属性进行获取—（如果是通过函数的方式，则通过形参的方式进行获取）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Vue初步分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/26/Vue初步分析/" class="article-date">
      <time datetime="2019-05-26T13:21:44.465Z" itemprop="datePublished">2019-05-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/Vue初步分析/">Vue初步分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Vue的简介"><a href="#Vue的简介" class="headerlink" title="Vue的简介"></a>Vue的简介</h1><ul>
<li>Vue是一套用于构建用户界面的渐进式框架</li>
<li>可以自底向上逐层引用</li>
<li>Vue的核心库只关注视图层</li>
</ul>
<h1 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h1><ul>
<li>跨组件数据流 </li>
<li>自定义事件通信</li>
<li>构建工具集成</li>
<li>单向数据流</li>
</ul>
<h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is=<span class="string">"currentTabComponent"</span>&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">在上述的示例中，currentTabComponent 可以包括</span><br><span class="line">	已注册组件的名字</span><br><span class="line">	一个组件的选项对象</span><br></pre></td></tr></table></figure>
<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><p>如果你的组件颗粒度很小，那么可以考虑将其注册在全局上</p>
<p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</strong></p>
<h4 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>即使传递的是静态数组，也需要使用v-bind</p>
</li>
<li><p>单向数据流</p>
<ul>
<li>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</li>
<li>如果真的需要改<ul>
<li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong></li>
<li><strong>这个 prop 以一种原始的值传入且需要进行转换</strong></li>
</ul>
</li>
</ul>
<p>​</p>
</li>
</ul>
<h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><p>var vm = new Vue({</p>
<p>​    el: ‘#example’,    Vue 实例使用的根 DOM 元素</p>
<p>​    data: data,    Vue实例观察的数据对象，Vue实例代理了对其data对象属性的访问</p>
<p>​    props    当前组件接收到的props对象，Vue实例代理了对其props对象属性的访问</p>
<p>​    options</p>
<p>​        用于当前Vue实例的初始化选项。需要在选项中包含自定义属性时会有用处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  customOption: &apos;foo&apos;,</span><br><span class="line">  created: function() &#123;</span><br><span class="line">    console.log(this.$options.customOption) =&gt; &apos;foo&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​    parent    父实例，如果当前实例有的话</p>
<p>​    root    当前组件树的根实例，如果没有父实例–将会是其自己</p>
<p>​    children</p>
<p>​        当前实例的直接子组件，需要注意$children并不保证顺序，也不是响应式的。</p>
<p>​        如果你发现自己正在尝试使用$children来进行数据绑定，考虑使用一个数组配置v-for来生成子组件，并且使用Array作为真正的来源</p>
<p>​    slots</p>
<p>​    scopedSlots</p>
<p>​    refs        一个对象，持有注册过 <strong>ref</strong>特性的所有的DOM元素和组件实例</p>
<p>​    isServer    当前 Vue 实例是否运行于服务器。</p>
<p>​    attrs     { [key: string]: string }</p>
<p>​        包含了父作用域中不作为prop被识别（且获取）的特性绑定（class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过v-bind=”$attrs”传入内部组件</p>
<p>​    listeners</p>
<p>​        包含了父作用域中的（不含.native修饰器的）v-on 事件监听器。它可以通过v-on=”$listeners” 传入内部组件</p>
<p>});</p>
<p>所有的Vue组件都是Vue实例，并且接受相同的选项对象（一些根实例特有的选项除外:el） –参考Vue-router</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch(expOrFn, callback, [options])"></a>vm.$watch(expOrFn, callback, [options])</h5><ul>
<li><p>参数：</p>
<ul>
<li>{string | Function} expOrFn</li>
<li>{Function | Object} callback</li>
<li>{object} [options]<ul>
<li>{boolean} deep</li>
<li>{boolean} immediate</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值： {Function} unwatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="string">'do something'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, Fun);</span><br><span class="line">取消观察操作</span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项 ：deep</p>
<ul>
<li><p>为了发现对象内部值的变化，可以在选项参数中指定 <strong>deep: true</strong> 。–（注意数组不需要这么做）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// callback is fired</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>选项：immediate</p>
<ul>
<li><p>在选项参数中指定 <strong>immediate:true</strong> 将立即以表达式的当前值触发回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 'a' 的当前值触发回调</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="vm-set-target-propertyName-index-value"><a href="#vm-set-target-propertyName-index-value" class="headerlink" title="vm.$set(target, propertyName/index, value);"></a>vm.$set(target, propertyName/index, value);</h5><h5 id="vm-delete-target-propertyName-index-value"><a href="#vm-delete-target-propertyName-index-value" class="headerlink" title="vm.$delete(target,propertyName/index,value);"></a>vm.$delete(target,propertyName/index,value);</h5><h4 id="实例属性-数据"><a href="#实例属性-数据" class="headerlink" title="实例属性-数据"></a>实例属性-数据</h4><ul>
<li>只有当实例被创建时，data中存在的属性才是响应式的<ul>
<li>递归defineProperty() ,采用数据劫持结合发布-订阅模式</li>
</ul>
</li>
<li>如果你知道你晚些会用一些值，你需要设置一些初始值</li>
<li>唯一的例外是使用Object.freeze() <ul>
<li>无法再次修改本身及原型</li>
</ul>
</li>
</ul>
<p>向外暴露的<strong>实例</strong>属性和方法</p>
<p>vm.$data === data; =&gt; true</p>
<p>vm.$el === document.getElementById(‘example’) =&gt; true</p>
<p>vm.$watch (‘a’, function(newValue, oldValue) {})</p>
<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性将被混入到vue的实例中</span></span><br><span class="line">computed: &#123;</span><br><span class="line"><span class="comment">//计算属性的getter</span></span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向vm实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">《tips》: 如果使用了箭头函数，需要传递一个参数--获取vm实例对象</span><br><span class="line">		计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖（比如非响应式属性）在该实例范畴之外，则计算属性是不会被更新的 --- 比如为对象新增一个属性，这个属性一开始没被定义</span><br><span class="line">        												（<span class="keyword">this</span>.myObject.newProperty = <span class="string">'hi'</span>)</span><br><span class="line">        	</span><br><span class="line"> -----------------------------------计算属性的setter----------------------------</span><br><span class="line">   computed: &#123;</span><br><span class="line">     fullName: &#123;</span><br><span class="line">       <span class="comment">// getter</span></span><br><span class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">       <span class="comment">// setter</span></span><br><span class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> names = newValue.split(<span class="string">''</span>);</span><br><span class="line">         <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">this</span>.lastName = names[names-length <span class="number">-1</span>]</span><br><span class="line">       &#125;  </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">现在再运行  vm.fullNam = <span class="string">'ken Done'</span> 时，setter会被调用</span><br></pre></td></tr></table></figure>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然计算属性在大多数情况下更合适，但是在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  question: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.answer = <span class="string">'wait ...'</span></span><br><span class="line">    <span class="keyword">this</span>.someMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>创建前后</p>
<p>挂载前后</p>
<p>更新前后</p>
<p>删除前后</p>
<h1 id="DOM模板的注意事项"><a href="#DOM模板的注意事项" class="headerlink" title="DOM模板的注意事项"></a>DOM模板的注意事项</h1><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p>
<p>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 <code>is</code> 特性给了我们一个变通的办法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"blog-post-row"</span>&gt;&lt;/tr&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>
<p>—————————————————-或者使用.vue文件的template模板</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 Ken
                个人总结
            </div>
            <div class="footer-right">
                <span id="busuanzi_container_site_pv">
                    本站总访问量<span id="busuanzi_value_site_pv"></span>次
                </span>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <script type="text/Javascript"> document.onselectstart=function(e){return false;}; </script>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
            
            
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
  <script type="text/javascript" color="234,11,90" opacity='1' src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>