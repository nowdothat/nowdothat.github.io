<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Ken" />


    
    


<meta name="description" content="vue react 前端个人总结">
<meta name="keywords" content="vue react 前端个人总结">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome back">
<meta property="og:url" content="https://nowdothat.github.io/page/2/index.html">
<meta property="og:site_name" content="Welcome back">
<meta property="og:description" content="vue react 前端个人总结">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome back">
<meta name="twitter:description" content="vue react 前端个人总结">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">




    <link rel="shortcut icon" href="/img/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Welcome back</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Ken</a></h1>
        </hgroup>

        
        <p class="header-subtitle">675062812@qq.com</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/nowdothat/vue">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">本站内容均为个人学习总结，欢迎指正。邮箱：kencall@163.com</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Ken</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Ken</a></h1>
            </hgroup>
            
            <p class="header-subtitle">675062812@qq.com</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/26/TCP/" class="article-date">
      <time datetime="2019-06-26T14:52:14.126Z" itemprop="datePublished">2019-06-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/26/TCP/">TCP/IP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="什么是TCP-IP协议"><a href="#什么是TCP-IP协议" class="headerlink" title="什么是TCP/IP协议"></a>什么是TCP/IP协议</h1><ul>
<li><p>TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是TCP和IP。因此，大部分网络管理员称整个协议族为“TCP/IP”。</p>
</li>
<li><p>TCP/IP的迅速流行要归功于它的低成本、可在不同的平台间进行通信的能力和它开放的特性。“开放”的意思是软件开发人员可以自由地使用和修改TCP/IP的核心协议。TCP/IP是Internet实际采用的标准。UNIX和Linux一直都使用TCP/IP，Windows网络操作系统也以TCP/IP作为默认的协议。</p>
</li>
</ul>
<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><ul>
<li>链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
<p><img src="/2019/06/26/TCP/snipaste_level.png" alt="snipaste_level"></p>
<ol>
<li>第一层：网络接口层：TCP/IP协议的最低一层，对实际的网络媒体的管理，包括操作系统中的设备驱动程序和计算机对应的网络接口</li>
<li>第二层：网络层：该层负责相同或不同网络中计算机之间的通信主要处理数据包和路由。数据包是网络传输的最小数据单位。通过某条传输路线将数据包传给对方。IP协议,ICMP协议，IGMP协议。在IP层中，ARP协议用于将IP地址转换成物理地址，ICMP协议用于报告差错和传送控制信息。IP协议在TCP/IP协议组中处于核心地位。</li>
<li>第三层：传输层：提供TCP(传输控制协议)，UDP（用户数据报协议）两个协议，主要功能是数据格式化、数据确认和丢失重传等。</li>
<li>第四层：应用层：TCP/IP协议的<strong>应用层</strong>相当于OSI模型的<strong>会话层、表示层和应用层</strong>，FTP(文件传输协议)，DNS（域名系统），HTTP协议，Telnet（网络远程访问协议）</li>
</ol>
<h1 id="本文主讲第三层的TCP传输控制协议"><a href="#本文主讲第三层的TCP传输控制协议" class="headerlink" title="本文主讲第三层的TCP传输控制协议"></a>本文主讲第三层的TCP传输控制协议</h1><p><code>简述</code></p>
<p>TCP将包排序并进行错误检查，同时实现<a href="https://baike.baidu.com/item/%E8%99%9A%E7%94%B5%E8%B7%AF/1609903" target="_blank" rel="noopener">虚电路</a>间的连接。TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。</p>
<p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p><code>tcp包结构</code></p>
<p><img src="/2019/06/26/TCP/snipaste_tcpdata.png" alt="snipaste_tcpdata"></p>
<p>以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head），即MTU(Maximum Transmission Unit)为1500</p>
<p><img src="/2019/06/26/TCP/snipaste_MTUSize.png" alt="snipaste_MTUSize"></p>
<p>所以TCP包的大小：MTU字节大小1500-IP头部信息20-TCP头长度20-TCP timestrap option12 = 1448Byte</p>
<p><img src="/2019/06/26/TCP/snipaste_TCPDataPage.png" alt="snipaste_TCPDataPage"></p>
<p>根据上面这张图，可得知：IP数据包在以太网数据包里面,TCP数据包在IP数据包里面</p>
<h3 id="tcp的序号seq"><a href="#tcp的序号seq" class="headerlink" title="tcp的序号seq"></a>tcp的序号seq</h3><p>TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收</p>
<p>当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295(二的32次方-1)之间的任意值———tcp/ip详解协议卷第18章18.2.3解释初始序列号随时间变化，每个连接有不同的初始序列号，每4ms加一</p>
<hr>
<p>在 TCP 数据报中，有一个 序列号 (Sequence Number)。如果序列号被人猜出来，就会展现出 TCP 的脆弱性。</p>
<p>如果选择合适的序列号、IP地址以及端口号，那么任何人都能伪造出一个 TCP 报文段，从而 打断 TCP 的正常连接[RFC5961]。一种抵御上述行为的方法是使初始序列号(或者临时端口 号[RFC6056])变得相对难以被猜出，而另一种方法则是加密。</p>
<p>Linux 系统采用一个相对复杂的过程来选择它的初始序列号。它采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量。随机偏移量是在连接标识(由 2 个 IP 地址与 2 个端口号构成的 4 元组，即 4 元组)的基础上利用加密散列函数得到的。散列函数的输人每隔 5 分钟就会改变一次。在 32 位的初始序列号中，最高的 8 位是一个保密的序列号，而剩余的备位则由散列函数生成。上述方法所生成的序列号很难被猜出，但依然会随着时间而逐步增加。据报告显示， Windows 系统使用了一种基于 RC4[S94] 的类似方案。</p>
<h4 id="数据包的分割"><a href="#数据包的分割" class="headerlink" title="数据包的分割"></a>数据包的分割</h4><p>那么一次性发送大量数据，就必须分成多个包。比如，一个 100000字节大小的文件/MSS最大报文长度 = TCP报文段</p>
<h3 id="tcp的确认号ack"><a href="#tcp的确认号ack" class="headerlink" title="tcp的确认号ack"></a>tcp的确认号ack</h3><ol>
<li><p>发送数据： 服务器向客户端发送一个带有数据的数据包。该数据包中的序列号和确认号与建立连接的第三步的数据包的序列号和确认号相同</p>
</li>
<li><p>确认收到: 客户端收到该数据包，向服务器发送一个确认数据包。该数据包中，序列号是为上一个数据包中的确认号值</p>
<p>这个确认号为服务器发送的上一个数据包中的序列号+该数据包中所带的数据的大小</p>
<p>回复确认收到的ack = 收到了序列号 + 数据的大小（同时也表示下一次期望收到的序号）</p>
</li>
</ol>
<ul>
<li>主机A接收主机b 假设编号为0-535的字节（意味着mss值为535byte）,主机A会在发往主机B的报文段的确认号字段ack上填上536</li>
<li><p>每一个包都可以得到seq和ack, 接收方就可以根据编号进行排序（按照什么顺序进行还原原始文件）或者丢弃。发送方根据ack判断接收方是否收到了指定包，判断是否需要重传</p>
<p> ——————这样就保证了数据通信的完整性和可靠性，防止丢包</p>
</li>
</ul>
<h1 id="tcp头字段"><a href="#tcp头字段" class="headerlink" title="tcp头字段"></a>tcp头字段</h1><table>
<thead>
<tr>
<th>seq</th>
<th>序号 32位标识数据段在已发送的数据流中的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>ack</td>
<td>确认号,验证是否已被接收</td>
</tr>
<tr>
<td>SYN</td>
<td>为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步</td>
</tr>
<tr>
<td>ACK</td>
<td>为1表示确认号字段有效</td>
</tr>
<tr>
<td>FIN</td>
<td>为1表示发送方没有数据要传输了，要求释放连接。</td>
</tr>
<tr>
<td>PSH</td>
<td>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</td>
</tr>
<tr>
<td>RST</td>
<td>为1表示出现严重差错。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求</td>
</tr>
</tbody>
</table>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为32位的随机数<strong>A</strong>。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为<strong>A+1</strong>，SYN/ACK包本身又有一个随机产生的序号<strong>B</strong>。</li>
<li>最后，客户端再发送一个<a href="https://zh.wikipedia.org/wiki/%E7%A2%BA%E8%AA%8D%E8%A8%8A%E6%81%AF" target="_blank" rel="noopener">ACK</a>。此时包的Seq被设定为<strong>A+1</strong>，而ACK的确认码则为<strong>B+1</strong>(第二次握手,服务端返回的Next seq)。当服务端收到这个ACK的时候，就完成了三次握手，并进入了连接创建状态。</li>
<li>这里的+1是根据发送的length来决定的</li>
</ol>
<p><img src="/2019/06/26/TCP/snipaste_startConnect.png" alt="snipaste_startConnect"></p>
<p>这里需要注意, SYN=0 在抓包工具上来看,就是没设置的意思</p>
<h2 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h2><p>发送方发送syn = 1, 和</p>
<p> TCP Options</p>
<ul>
<li>Maximum segment size: 65475    – MSS : 最大片段大小</li>
<li>Window scale: 8 (multiply by 256)  – WS: “ TCP窗口比例”选项是一个选项，用于增加“传输控制协议”中允许的接收窗口大小，使其超过其以前的最大值65535字节</li>
<li>window size value: 65535  –Win </li>
<li>SACK permitted <ul>
<li>That’s the “Sack-Permitted” option from <a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">RFC 2018</a>, “TCP Selective Acknowledgment Options”. It says that the two machines can use “selective acknowledgment”, meaning that, instead of just saying “I got all bytes up to this sequence number”, they can say “I got all the bytes in this range and all the bytes in this other range”, with the implication being that bytes in ranges not listed were <em>not</em> received, so that they can say that they got bytes before and after some ranges, but not the bytes in the middle of the range. </li>
</ul>
</li>
</ul>
<p><img src="/2019/06/26/TCP/1600271255259.png" alt="1600271255259"></p>
<p><img src="/2019/06/26/TCP/1600271300193.png" alt="1600271300193"></p>
<h2 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h2><p><img src="/2019/06/26/TCP/1600271441785.png" alt="1600271441785"></p>
<h2 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h2><p><img src="/2019/06/26/TCP/1600271468100.png" alt="1600271468100"></p>
<p>这里有点疑惑的是: 并没有设置 syn flags</p>
<h2 id="通过三次握手之后-建立-HTTP连接通道"><a href="#通过三次握手之后-建立-HTTP连接通道" class="headerlink" title="通过三次握手之后,建立 HTTP连接通道"></a>通过三次握手之后,建立 HTTP连接通道</h2><p><img src="/2019/06/26/TCP/1600271749837.png" alt="1600271749837"></p>
<p><img src="/2019/06/26/TCP/1600271665014.png" alt="1600271665014"></p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>服务端发送的seq和ack必须和第三次客户端回传的seq和ack保持一致</p>
<p>客户端确认收到：seq = 服务端的ack  ack = 服务端的seq+该数据包中所带数据的大小（同时也表示下一次期望收到的序号）</p>
<p>服务器回应：seq = 客户端回传的ack  ack = 客户端回传的seq+客户端回传的length</p>
<h2 id="服务器开始在通道里传送数据"><a href="#服务器开始在通道里传送数据" class="headerlink" title="服务器开始在通道里传送数据"></a>服务器开始在通道里传送数据</h2><p><img src="/2019/06/26/TCP/1600272018881.png" alt="1600272018881"></p>
<h2 id="客户端接收-http-数据"><a href="#客户端接收-http-数据" class="headerlink" title="客户端接收 http 数据"></a>客户端接收 http 数据</h2><p><img src="/2019/06/26/TCP/1600272340194.png" alt="1600272340194"></p>
<p><img src="/2019/06/26/TCP/1600272419339.png" alt="1600272419339"></p>
<p>接收http 200之后,需要传递给服务器</p>
<p><img src="/2019/06/26/TCP/1600272907328.png" alt="1600272907328"></p>
<h2 id="失败的情况"><a href="#失败的情况" class="headerlink" title="失败的情况"></a>失败的情况</h2><p>如果客户端并没有接收到想要的信息,会再发一次tcp 请求</p>
<p>如果服务端已经完成 tcp连接,进入下一步</p>
<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><h2 id="服务端关闭请求"><a href="#服务端关闭请求" class="headerlink" title="服务端关闭请求"></a>服务端关闭请求</h2><p><img src="/2019/06/26/TCP/1600273605916.png" alt="1600273605916"></p>
<h2 id="客户端回复tcp"><a href="#客户端回复tcp" class="headerlink" title="客户端回复tcp"></a>客户端回复tcp</h2><p><img src="/2019/06/26/TCP/1600273696962.png" alt="1600273696962"></p>
<p>在这个过程中连接的每一侧都独立地被终止。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认</p>
<p><code>首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接</code></p>
<p>注意： 首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接</p>
<p><img src="/2019/06/26/TCP/snipaste_stopConnect.png" alt="snipaste_stopConnect"></p>
<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p><img src="/2019/06/26/TCP/snipaste_summanry.png" alt="snipaste_summanry"></p>
<p><img src="/2019/06/26/TCP/1600309272878.png" alt="1600309272878"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入Vue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/13/深入Vue/" class="article-date">
      <time datetime="2019-06-12T23:31:29.050Z" itemprop="datePublished">2019-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/深入Vue/">深入Vue</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="构建Vue实例"><a href="#构建Vue实例" class="headerlink" title="构建Vue实例"></a>构建Vue实例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 手动构建元素</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue/dist/vue.js'</span> <span class="comment">//注意，需要制定vue运行版本</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: div,</span><br><span class="line">  template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">如果在<span class="keyword">new</span>实例时，没有指定el，可以进行,跟上面一样的效果</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">app.$mount(<span class="string">'#root'</span>)</span><br><span class="line"><span class="comment">// 当执行的时候，模板文件会将el的节点进行替换</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 通过html-webpack-plugin插件进行生成插入</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./index.html'</span></span><br><span class="line">  &#125;),</span><br></pre></td></tr></table></figure>
<h1 id="Vue实例属性"><a href="#Vue实例属性" class="headerlink" title="Vue实例属性"></a>Vue实例属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> 			 el: div,</span><br><span class="line">  			 template: <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span></span><br><span class="line">		   &#125;)</span><br><span class="line">该app常量就是Vue实例自动绑定的<span class="keyword">this</span>,意味着下面的app.$属性，即为<span class="keyword">this</span>.$属性</span><br></pre></td></tr></table></figure>
<ul>
<li>app.$data data()定义的值</li>
<li>app.$props 组件传值</li>
<li>app.$el ATS抽象树</li>
<li>app.$options  合成过后的属性-即为整个实例</li>
<li>app.$options.render =  (h)  =&gt; {return h(‘div’, {}, ‘new render content’ )}  当页面数据进行更新的时候，会触发这个函数</li>
<li>app.$root  就是app本身</li>
<li>app.$children  类似于react的props.children <item><code>&lt;div&gt;这个div就是children值&lt;/div&gt;</code> </item></li>
<li>app.$parent    查找父组件 app.$ $parent.$options.name    一般配合extend使用</li>
<li>app.$slots</li>
<li>app.$scopedSlots</li>
<li>app.$refs  ref指定的元素数组集合，可以进行操纵DOM</li>
<li>app.$isServer  服务端渲染用</li>
<li>app.$on(‘事件名’, (子组件params1, paramsTwo) =&gt; {})</li>
<li>app.$emit(‘事件名’, 传给父组件参数1， 参数2)</li>
<li>app.$set(app.obj, ‘a属性’, 修改的值)</li>
<li>app.$delete(app.obj, 要删除的属性)</li>
<li>app.$forceUpdate() 强制更新视图，与react类似</li>
<li>app.$destroy() 销毁实例，一般不会去做</li>
</ul>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>如果使用watch方法，没有控制好，有可能会造成内存溢出，所以，在某些情况下可能需要移除watch</p>
<p>watch和computed都不要去修改监听的值，否则会造成无限循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unWatch = <span class="keyword">this</span>.$watch(<span class="string">'text'</span>, (newVal,oldVal) =&gt; &#123;&#125;)</span><br><span class="line">unWatch() 注销watch</span><br><span class="line"></span><br><span class="line">如果使用Vue模板文件，可以这样写</span><br><span class="line">watch: &#123;</span><br><span class="line">  text (newVal,oldVal) &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">模板文件的watch，会被编译成handler方法，如果我们手动写handler方法，可以使用immediate：<span class="literal">true</span>使watch立即执行</span><br><span class="line">watch: &#123;</span><br><span class="line">  text: &#123;</span><br><span class="line">    handler (newVal, oldVal) &#123;</span><br><span class="line">      <span class="keyword">do</span> some thing</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    deep: <span class="literal">true</span> <span class="comment">// 默认为false 是否watch 对象键值 -遍历对象，消耗性能，解决办法监听'text.a'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Vue跟react的更新生命周期形式很类型, Vue：beforeUpdate | update — React: componentWillUpdate | compoentDidUpdate。不同的是，react在执行componentDidUpdate前，会先执行render()方法,Vue没有</p>
<ul>
<li>vue跟react都有强制更新视图的操作this.forceUpdate()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue编译我们的template模板，最后为render方法输出。render方法在mounted前进行调用，所以beforeMount()生命周期<span class="keyword">this</span>-不指向Vue实例</span><br><span class="line">render (h) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'render error'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">renderError (h, err) &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, &#123;&#125;, err.stack)</span><br><span class="line">  <span class="comment">// 这个不会捕获子组件的报错，只能在生产环境下使用</span></span><br><span class="line">&#125;,</span><br><span class="line">errorCaptured (h, err) &#123;&#125;</span><br><span class="line"><span class="comment">//这个会向上冒泡，并能在正式环境中使用</span></span><br></pre></td></tr></table></figure>
<h3 id="原生指令"><a href="#原生指令" class="headerlink" title="原生指令"></a>原生指令</h3><ul>
<li>v-model.number  转换字符串为数字</li>
<li>v-model.trim  去除空格</li>
<li>v-model.lazy    change的时候才进行改变</li>
<li>v-pre   不进行解析表达式，页面展示模板字符串</li>
<li>v-once 只绑定一次</li>
<li>v-cloak 使用场景少</li>
</ul>
<h3 id="props严格验证"><a href="#props严格验证" class="headerlink" title="props严格验证"></a>props严格验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  active: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    validator (value) &#123;</span><br><span class="line">    <span class="comment">// value就是传进来的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'boolean'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>vue的双向绑定和react基本一致，都是采用e.target.value的方式进行绑定</p>
<p>子组件=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; @input=&quot;handleInput&quot;&gt;</span><br><span class="line"></span><br><span class="line">function handleInput(e) &#123;</span><br><span class="line">	this.$emit(&apos;input&apos;, e.target.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件 = </p>
<p>value=”value” @input=”value = arguments[0]”</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义一个组件</span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  	&lt;div&gt;</span></span><br><span class="line"><span class="string">		&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">		&lt;slot name="body"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">	&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">调用组件</span><br><span class="line">&lt;comp-one&gt;</span><br><span class="line">	&lt;span&gt;show the slot&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span slot="body"&gt;show the bodyName slot&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/comp-one&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作用域插槽的概念</span><br><span class="line">	一般来讲，组件内部的变量是根据当前引用组件的变量来变化的</span><br><span class="line">    如果使用了slot-scope，就可以使用当前组件内部定义的变量+引用组件的变量</span><br><span class="line">定义组件</span><br><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  	&lt;div&gt;</span></span><br><span class="line"><span class="string">		&lt;slot value="456"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">	&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">引用组件-通过props.定义值来调用，引用组件的值可以直接写</span><br><span class="line">&lt;comp-one&gt;</span><br><span class="line">  &lt;span slot-scope=<span class="string">"props"</span>&gt;&#123;&#123;props.value&#125;&#125;&#123;&#123;currentData&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>comp-one&gt;</span><br></pre></td></tr></table></figure>
<h3 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">爷爷级组件</span><br><span class="line">provide() &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, <span class="string">'value'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.value,</span><br><span class="line">    enumerable: <span class="literal">true</span> <span class="comment">//提供可读</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    yeye: <span class="keyword">this</span>,</span><br><span class="line">    value: <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">孙级组件</span><br><span class="line">inject: [<span class="string">'yeye'</span>, <span class="string">'data'</span>]</span><br><span class="line">调用-- <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;data.value&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">这种方法适用于简单的组件级通信，解决只能父子组件通信的问题。如果交互的数据量比较多，可以采用vuex通信</span><br></pre></td></tr></table></figure>
<h3 id="render方法"><a href="#render方法" class="headerlink" title="render方法"></a>render方法</h3><p>首先我们需要明白：构建Vue组件有三种方式 ：<code>template</code> / <code>renderFunction</code> / <code>js</code></p>
<p>在mounted生命周期前调用render方法，默认传入this.$createElement方法，该方法可以创建一个vnode节点，用来跟DOM节点进行对比</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">模板文件为</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;comp-one ref="comp"&gt;</span></span><br><span class="line"><span class="string">  	&lt;span ref="span"&gt;&#123;&#123;value&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/comp-one&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">---------------------转换成render方法---------------------</span><br><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">  	<span class="string">'comp-one'</span>,</span><br><span class="line">  	&#123;</span><br><span class="line">      ref: <span class="string">'comp'</span></span><br><span class="line">  	&#125;,</span><br><span class="line">  	[</span><br><span class="line">      createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">        ref: <span class="string">'span'</span></span><br><span class="line">      &#125;, <span class="keyword">this</span>.value)</span><br><span class="line">  	]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">注意点： 加入子节点的的时候，需要使用数组createdElement(<span class="string">'节点名称'</span>,&#123;属性&#125;, 值)</span><br><span class="line">如果是slot,则是</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">  	&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">render(createdElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createdElement(<span class="string">'div'</span>, &#123;<span class="attr">style</span>: <span class="keyword">this</span>.style&#125;, <span class="keyword">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="事件的渲染"><a href="#事件的渲染" class="headerlink" title="事件的渲染"></a>事件的渲染</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">------------------组件内部------------------</span><br><span class="line">props: [<span class="string">'props1'</span>],</span><br><span class="line">name: <span class="string">'comp'</span>,</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div :style="style"&gt;</span></span><br><span class="line"><span class="string">  	&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">--------------------转换render--------------</span><br><span class="line">render(createdElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createdElement(<span class="string">'div'</span>, </span><br><span class="line">     &#123;</span><br><span class="line">    	style: <span class="keyword">this</span>.style,</span><br><span class="line">    	on: &#123;</span><br><span class="line">          click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">this</span>.$emit(<span class="string">'click'</span>)&#125;<span class="comment">// 注意与nativeOn的区别</span></span><br><span class="line">    	&#125;</span><br><span class="line">  	 &#125;, [</span><br><span class="line">		<span class="keyword">this</span>.$slots.default,</span><br><span class="line">    	<span class="keyword">this</span>.props1</span><br><span class="line">	 ])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">--------------------------引用组件-------------------------</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick() &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">  	<span class="string">'comp-one'</span>,</span><br><span class="line">  	&#123;</span><br><span class="line">      ref: <span class="string">'comp'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        props1: <span class="keyword">this</span>.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.handeleClick</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;,</span><br><span class="line">  	[</span><br><span class="line">      createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">        ref: <span class="string">'span'</span></span><br><span class="line">      &#125;, <span class="keyword">this</span>.value)</span><br><span class="line">  	]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果采用nativeOn: &#123;</span><br><span class="line">  click: <span class="keyword">this</span>.handleClick<span class="comment">//是将事件直接绑定在根节点上，不需要采用on/emit的方式</span></span><br><span class="line">  												<span class="comment">//意味着组件上不需要定义on事件就可以直接触发了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="具名插槽的render方式"><a href="#具名插槽的render方式" class="headerlink" title="具名插槽的render方式"></a>具名插槽的render方式</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通插槽使用<span class="keyword">this</span>.$slots.default生成一个vnode节点</span><br><span class="line">具名插槽使用<span class="keyword">this</span>.$slots.名称生成vnode节点</span><br><span class="line">------定义组件------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.$slots.header)</span><br><span class="line">&#125;</span><br><span class="line">------引用组件-------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, [</span><br><span class="line">    createElement(<span class="string">'span'</span>, &#123;<span class="attr">slot</span>: <span class="string">'header'</span>&#125;,<span class="string">'123'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="添加原生DOM属性"><a href="#添加原生DOM属性" class="headerlink" title="添加原生DOM属性"></a>添加原生DOM属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------引用组件-------</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, [</span><br><span class="line">    createElement(<span class="string">'span'</span>, &#123;</span><br><span class="line">      slot: <span class="string">'header'</span>,</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        innerHTML: <span class="string">'&lt;span&gt;原生DOM添加了元素节点&lt;/span&gt;'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: <span class="string">'test-id'</span><span class="comment">//给原生DOM上添加了id属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">'123'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-react入门指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/02/react入门指南/" class="article-date">
      <time datetime="2019-06-02T14:39:13.463Z" itemprop="datePublished">2019-06-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/02/react入门指南/">React基础总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h1><p>React 应用程序的组成部分： 元素和组件</p>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><h3 id="JSX语法介绍"><a href="#JSX语法介绍" class="headerlink" title="JSX语法介绍"></a>JSX语法介绍</h3><p>我们建议<a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">使用 JSX</a> 来编写你的 UI 组件。每个 JSX 元素都是调用 <a href="https://react.docschina.org/docs/react-api.html#createelement" target="_blank" rel="noopener"><code>React.createElement()</code></a> 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用以下方法。</p>
<ul>
<li><a href="https://react.docschina.org/docs/react-api.html#createelement" target="_blank" rel="noopener"><code>createElement()</code></a></li>
<li><a href="https://react.docschina.org/docs/react-api.html#createfactory" target="_blank" rel="noopener"><code>createFactory()</code></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">JSX 是JavaScript 的语法扩展，它具有 JavaScript 的全部功能。</span><br><span class="line"></span><br><span class="line">React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</span><br><span class="line"></span><br><span class="line">React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</span><br><span class="line"></span><br><span class="line">React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</span><br><span class="line"></span><br><span class="line">在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，<span class="number">2</span> + <span class="number">2</span>，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式.下面是个简单的例子</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">            我们将一个js表达式插进jsx语法中，并实现了'Harper Perez'</span></span><br><span class="line"><span class="regexp">            如果是在Vue项目中，我们可以使用computed计算属性进行这样的操作</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">  注意：我们在定义element变量的时候，使用的是()的形式。原因是：我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。</span></span><br></pre></td></tr></table></figure>
<h6 id="jsx也是一个表达式，意味着可以进行函数渲染"><a href="#jsx也是一个表达式，意味着可以进行函数渲染" class="headerlink" title="jsx也是一个表达式，意味着可以进行函数渲染"></a>jsx也是一个表达式，意味着可以进行函数渲染</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="JSX的特定属性"><a href="#JSX的特定属性" class="headerlink" title="JSX的特定属性"></a>JSX的特定属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// ""和&#123;&#125;只能同时使用一个，对于同一属性不能同时使用这2种符号</span></span><br></pre></td></tr></table></figure>
<p><strong>警告：</strong></p>
<p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
<p>例如，JSX 里的 <code>class</code> 变成了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，而 <code>tabindex</code> 则变为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p>
<h6 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h6><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const element = React.createElement(</span></span><br><span class="line"><span class="regexp">  'h1',</span></span><br><span class="line"><span class="regexp">  &#123;className: 'greeting'&#125;,</span></span><br><span class="line"><span class="regexp">  'Hello, world!'</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">-------------------------------------简化编译---------------------------------</span></span><br><span class="line"><span class="regexp">  const element = &#123;</span></span><br><span class="line"><span class="regexp">  type: 'h1',</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    className: 'greeting',</span></span><br><span class="line"><span class="regexp">    children: 'Hello, world!'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="react元素不可变性"><a href="#react元素不可变性" class="headerlink" title="react元素不可变性"></a>react元素不可变性</h3><p>React 元素是<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变对象</a>。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件也可以被定义为可被包装的函数</p>
<p>定义组件最简单的方式就是编写 JavaScript 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>
<p>你同时还可以使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 的 class</a> 来定义组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个组件在 React 里是等效的</p>
<h6 id="自定义函数组件"><a href="#自定义函数组件" class="headerlink" title="自定义函数组件"></a>自定义函数组件</h6><p>React 元素也可以是用户自定义的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br></pre></td></tr></table></figure>
<p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<p>例如，这段代码会在页面上渲染 “Hello, Sara”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br><span class="line"><span class="xml">// 分析步骤：</span></span><br><span class="line"><span class="xml">	1. 我们调用ReactDom.render()函数，并传入jsx语法变量elemnnt作为参数</span></span><br><span class="line"><span class="xml">    2. React调用Welcome组件， 并将&#123;name: 'Sara'&#125;作为props传入</span></span><br><span class="line"><span class="xml">    3. Welcome组件将 jsx对象作为返回值</span></span><br><span class="line"><span class="xml">    4. React DOM将DOM进行对比更新</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 组件名称必须以大写字母开头,React 会将以小写字母开头的组件视为原生 DOM 标签</p>
<p>​        <strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong>–类似于Vue的单向数据流，子组件不能修改父组件的传值，只能通过触发父组件的事件进行修改</p>
<p>​        所以我们只能修改组件内部的数据state，它 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。 —–对比Vue的data和props</p>
<h6 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h6><ul>
<li><p>不要直接修改state—使用setState({})</p>
<ul>
<li>构造函数是唯一可以给 <code>this.state</code> 赋值的地方</li>
</ul>
</li>
<li><p>state的更新可能是异步的</p>
<ul>
<li><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</p>
</li>
<li><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line">要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>state的更新会被合并</p>
<ul>
<li>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state</li>
<li>这就意味着：当你的state对象里面有多个值时，你多次调用setState（{someKeys:xx}）这里的对象合并是浅合并，setState方法保留了其他未被重置的属性，但是完全替换了someKyes</li>
</ul>
</li>
</ul>
<h6 id="将函数组件转换为class组件"><a href="#将函数组件转换为class组件" class="headerlink" title="将函数组件转换为class组件"></a>将函数组件转换为class组件</h6><p>———–需要注意的是，如果是通过compoent={}的形式，需要在constructor(props)进行传递</p>
<ol>
<li><p>创建一个同名的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>，并且继承于 <code>React.Component</code>。</p>
</li>
<li><p>添加一个空的 <code>render()</code> 方法。</p>
</li>
<li><p>将函数体移动到 <code>render()</code> 方法之中。</p>
</li>
<li><p>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</p>
</li>
<li><p>删除剩余的空函数声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.Component 是使用 ES6 classes 方式定义 React 组件的基类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;<span class="keyword">do</span> some thing&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>———————通过以下方式将 <code>props</code> 传递到父类的构造函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。—使用表达式</li>
</ul>
<p>一般情况下，传入没有调用的函数都会丢失this指向，解决办法是使用Function.prototype.bind()或者是使用箭头函数，亦或者是class fields进行解决</p>
<h6 id="函数传入参数"><a href="#函数传入参数" class="headerlink" title="函数传入参数"></a>函数传入参数</h6><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="循环渲染需要带key"><a href="#循环渲染需要带key" class="headerlink" title="循环渲染需要带key"></a>循环渲染需要带key</h3><p>React 支持 <code>key</code> 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素</p>
<p>Vue的key属性也是做同样的事情，进行diffing算法运算</p>
<h1 id="react-PureComponet"><a href="#react-PureComponet" class="headerlink" title="react.PureComponet"></a>react.PureComponet</h1><p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。</p>
<h1 id="需要注意的小细节"><a href="#需要注意的小细节" class="headerlink" title="需要注意的小细节"></a>需要注意的小细节</h1><ul>
<li>autoFocus一定要配合tabIndexReact </li>
<li>来使用</li>
<li>constructor要配置super使用</li>
<li>渲染的时候要使用标签的形式进行渲染</li>
<li>在组件内部的dom元素中添加事件<ul>
<li><h2 onclick="{clickFun}"></h2>



</li>
</ul>
</li>
</ul>
<h4 id="组件渲染时的this问题"><a href="#组件渲染时的this问题" class="headerlink" title="组件渲染时的this问题"></a>组件渲染时的this问题</h4><p>react 在render({this.state.xx})拿值是可以，但是在执行函数的时候却为undefined的原因？<br>—因为js是单线程事件型语言，当遇到函数或者定时器等异步操作时，会先向下执行，等事件触发，或者有空闲的时候再执行异步操作–那个时候，上下文已经丢失，所以this执行就已经丢失了<br>———–办法就是，</p>
<ol>
<li>在dom渲染的时候，手动绑定上下文{this.事件名.bind(this)}</li>
<li>使用() =&gt; {利用箭头函数的特性绑定this}</li>
</ol>
<h4 id="组件的基本生命周期"><a href="#组件的基本生命周期" class="headerlink" title="组件的基本生命周期"></a>组件的基本生命周期</h4><p>以类定义的组件，都有一样的生命周期</p>
<ul>
<li>constructor() {}</li>
<li>componentWillMount() {} //加载前，可以进行拿取数据</li>
<li>render() {}</li>
<li>componentDidMount() {} //页面加载完成</li>
<li>if（进行更新state)————–<ul>
<li>componentWillUpdate() {} // 可以进行数据的验证</li>
<li>render()</li>
<li>compoentDidUpdate()  //更新完成</li>
</ul>
</li>
</ul>
<p>有一个this.forceUpdate() –强制更新DOM    </p>
<p>shouldCompoentUpdate() {return false} —不进行更新  — 控制componentWillUpdate的执行</p>
<p>————————————————————特殊的——————————————————</p>
<p>componentWillUnmount()—-:通过非React提供的方式注册的事件，通常需要在这个方法中注销事件，以及该组件中使用的计时器，也需要在这里清除！！！</p>
<h2 id="setState的作用"><a href="#setState的作用" class="headerlink" title="setState的作用"></a>setState的作用</h2><ol>
<li>可以用来更新数据</li>
<li>会自动地调用render()</li>
</ol>
<h2 id="父子组件中遇到的问题"><a href="#父子组件中遇到的问题" class="headerlink" title="父子组件中遇到的问题"></a>父子组件中遇到的问题</h2><p>父组件调用了render方法，则子组件必定会调用render方法。子组件调用render方法，则父组件不会调用render方法</p>
<p>父组件向子组件传值，是将父组件的数据或者方法作为子组件的属性值进行传递</p>
<p>​    子组件通过this.props.属性进行获取—（如果是通过函数的方式，则通过形参的方式进行获取）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Vue初步分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/26/Vue初步分析/" class="article-date">
      <time datetime="2019-05-26T13:21:44.465Z" itemprop="datePublished">2019-05-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/Vue初步分析/">Vue初步分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Vue的简介"><a href="#Vue的简介" class="headerlink" title="Vue的简介"></a>Vue的简介</h1><ul>
<li>Vue是一套用于构建用户界面的渐进式框架</li>
<li>可以自底向上逐层引用</li>
<li>Vue的核心库只关注视图层</li>
</ul>
<h1 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h1><ul>
<li>跨组件数据流 </li>
<li>自定义事件通信</li>
<li>构建工具集成</li>
<li>单向数据流</li>
</ul>
<h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is=<span class="string">"currentTabComponent"</span>&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">在上述的示例中，currentTabComponent 可以包括</span><br><span class="line">	已注册组件的名字</span><br><span class="line">	一个组件的选项对象</span><br></pre></td></tr></table></figure>
<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><p>如果你的组件颗粒度很小，那么可以考虑将其注册在全局上</p>
<p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</strong></p>
<h4 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>即使传递的是静态数组，也需要使用v-bind</p>
</li>
<li><p>单向数据流</p>
<ul>
<li>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</li>
<li>如果真的需要改<ul>
<li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong></li>
<li><strong>这个 prop 以一种原始的值传入且需要进行转换</strong></li>
</ul>
</li>
</ul>
<p>​</p>
</li>
</ul>
<h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><p>var vm = new Vue({</p>
<p>​    el: ‘#example’,    Vue 实例使用的根 DOM 元素</p>
<p>​    data: data,    Vue实例观察的数据对象，Vue实例代理了对其data对象属性的访问</p>
<p>​    props    当前组件接收到的props对象，Vue实例代理了对其props对象属性的访问</p>
<p>​    options</p>
<p>​        用于当前Vue实例的初始化选项。需要在选项中包含自定义属性时会有用处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  customOption: &apos;foo&apos;,</span><br><span class="line">  created: function() &#123;</span><br><span class="line">    console.log(this.$options.customOption) =&gt; &apos;foo&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​    parent    父实例，如果当前实例有的话</p>
<p>​    root    当前组件树的根实例，如果没有父实例–将会是其自己</p>
<p>​    children</p>
<p>​        当前实例的直接子组件，需要注意$children并不保证顺序，也不是响应式的。</p>
<p>​        如果你发现自己正在尝试使用$children来进行数据绑定，考虑使用一个数组配置v-for来生成子组件，并且使用Array作为真正的来源</p>
<p>​    slots</p>
<p>​    scopedSlots</p>
<p>​    refs        一个对象，持有注册过 <strong>ref</strong>特性的所有的DOM元素和组件实例</p>
<p>​    isServer    当前 Vue 实例是否运行于服务器。</p>
<p>​    attrs     { [key: string]: string }</p>
<p>​        包含了父作用域中不作为prop被识别（且获取）的特性绑定（class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过v-bind=”$attrs”传入内部组件</p>
<p>​    listeners</p>
<p>​        包含了父作用域中的（不含.native修饰器的）v-on 事件监听器。它可以通过v-on=”$listeners” 传入内部组件</p>
<p>});</p>
<p>所有的Vue组件都是Vue实例，并且接受相同的选项对象（一些根实例特有的选项除外:el） –参考Vue-router</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch(expOrFn, callback, [options])"></a>vm.$watch(expOrFn, callback, [options])</h5><ul>
<li><p>参数：</p>
<ul>
<li>{string | Function} expOrFn</li>
<li>{Function | Object} callback</li>
<li>{object} [options]<ul>
<li>{boolean} deep</li>
<li>{boolean} immediate</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值： {Function} unwatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="string">'do something'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, Fun);</span><br><span class="line">取消观察操作</span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项 ：deep</p>
<ul>
<li><p>为了发现对象内部值的变化，可以在选项参数中指定 <strong>deep: true</strong> 。–（注意数组不需要这么做）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// callback is fired</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>选项：immediate</p>
<ul>
<li><p>在选项参数中指定 <strong>immediate:true</strong> 将立即以表达式的当前值触发回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 'a' 的当前值触发回调</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="vm-set-target-propertyName-index-value"><a href="#vm-set-target-propertyName-index-value" class="headerlink" title="vm.$set(target, propertyName/index, value);"></a>vm.$set(target, propertyName/index, value);</h5><h5 id="vm-delete-target-propertyName-index-value"><a href="#vm-delete-target-propertyName-index-value" class="headerlink" title="vm.$delete(target,propertyName/index,value);"></a>vm.$delete(target,propertyName/index,value);</h5><h4 id="实例属性-数据"><a href="#实例属性-数据" class="headerlink" title="实例属性-数据"></a>实例属性-数据</h4><ul>
<li>只有当实例被创建时，data中存在的属性才是响应式的<ul>
<li>递归defineProperty() ,采用数据劫持结合发布-订阅模式</li>
</ul>
</li>
<li>如果你知道你晚些会用一些值，你需要设置一些初始值</li>
<li>唯一的例外是使用Object.freeze() <ul>
<li>无法再次修改本身及原型</li>
</ul>
</li>
</ul>
<p>向外暴露的<strong>实例</strong>属性和方法</p>
<p>vm.$data === data; =&gt; true</p>
<p>vm.$el === document.getElementById(‘example’) =&gt; true</p>
<p>vm.$watch (‘a’, function(newValue, oldValue) {})</p>
<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性将被混入到vue的实例中</span></span><br><span class="line">computed: &#123;</span><br><span class="line"><span class="comment">//计算属性的getter</span></span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向vm实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">《tips》: 如果使用了箭头函数，需要传递一个参数--获取vm实例对象</span><br><span class="line">		计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖（比如非响应式属性）在该实例范畴之外，则计算属性是不会被更新的 --- 比如为对象新增一个属性，这个属性一开始没被定义</span><br><span class="line">        												（<span class="keyword">this</span>.myObject.newProperty = <span class="string">'hi'</span>)</span><br><span class="line">        	</span><br><span class="line"> -----------------------------------计算属性的setter----------------------------</span><br><span class="line">   computed: &#123;</span><br><span class="line">     fullName: &#123;</span><br><span class="line">       <span class="comment">// getter</span></span><br><span class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">       <span class="comment">// setter</span></span><br><span class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> names = newValue.split(<span class="string">''</span>);</span><br><span class="line">         <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">this</span>.lastName = names[names-length <span class="number">-1</span>]</span><br><span class="line">       &#125;  </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">现在再运行  vm.fullNam = <span class="string">'ken Done'</span> 时，setter会被调用</span><br></pre></td></tr></table></figure>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然计算属性在大多数情况下更合适，但是在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  question: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.answer = <span class="string">'wait ...'</span></span><br><span class="line">    <span class="keyword">this</span>.someMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>创建前后</p>
<p>挂载前后</p>
<p>更新前后</p>
<p>删除前后</p>
<h1 id="DOM模板的注意事项"><a href="#DOM模板的注意事项" class="headerlink" title="DOM模板的注意事项"></a>DOM模板的注意事项</h1><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p>
<p>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 <code>is</code> 特性给了我们一个变通的办法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"blog-post-row"</span>&gt;&lt;/tr&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>
<p>—————————————————-或者使用.vue文件的template模板</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-VueRouter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/23/VueRouter/" class="article-date">
      <time datetime="2019-05-23T11:36:32.530Z" itemprop="datePublished">2019-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/VueRouter/">VueRouter总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#<router-link> 组件跳转</router-link></p>
<p><router-link>组件类似于a标签链接跳转.推荐理由：</router-link></p>
<ul>
<li><p>在history模式下，会触发守卫点击事件，让浏览器不再重新加载页面</p>
</li>
<li><p>在history模式下使用base选项之后。所有的to属性都不需要写基础路径了  —“ 默认为/“</p>
</li>
<li><p>可以使用JavaScript表达式</p>
<p>​</p>
</li>
</ul>
<h1 id="功能性组件"><a href="#功能性组件" class="headerlink" title=" 功能性组件"></a><router-view> 功能性组件</router-view></h1><p>这个组件是一个functionnal组件，渲染路径匹配到的视图组件，router-view可以进行多层嵌套</p>
<p>router-view 的props：–name 如果 <code>&lt;router-view&gt;</code>设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。下面以一个设置面板为例：</span><br><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;User Settings&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;NavBar/</span>&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">  &lt;router-view name=<span class="string">"helper"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">路由配置</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">  path: '/</span>settings<span class="string">',</span></span><br><span class="line"><span class="string">  // 你也可以在顶级路由就配置命名视图</span></span><br><span class="line"><span class="string">  component: UserSettings,</span></span><br><span class="line"><span class="string">  children: [&#123;</span></span><br><span class="line"><span class="string">    path: '</span>emails<span class="string">',</span></span><br><span class="line"><span class="string">    component: UserEmailsSubscriptions</span></span><br><span class="line"><span class="string">  &#125;, &#123;</span></span><br><span class="line"><span class="string">    path: '</span>profile<span class="string">',</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      default: UserProfile,</span></span><br><span class="line"><span class="string">      helper: UserProfilePreview</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当然了</span></span><br></pre></td></tr></table></figure>
<h1 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  linkExactActiveClass: <span class="string">'active'</span>, <span class="comment">//全局配置 &lt;router-link&gt; 精确激活的class 类名”</span></span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个的位置</span></span><br><span class="line">    <span class="keyword">if</span>(savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  base: <span class="string">'/'</span>,</span><br><span class="line">  fallback: <span class="literal">true</span> <span class="comment">//当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">分析实例配置：</span><br><span class="line">routes: 类型<span class="built_in">Array</span>&lt;RouteConfig&gt;</span><br><span class="line">  RouteConfig:</span><br><span class="line">  	<span class="number">1.</span> path: string</span><br><span class="line">    <span class="number">2.</span> component ? : Componetn; <span class="comment">// 组件-推荐使用() =&gt; import('@/views/some/someList')</span></span><br><span class="line">    <span class="number">3.</span> name ? : string; <span class="comment">//命名路由 --权限控制</span></span><br><span class="line">    <span class="number">4.</span> components? : &#123;[name: string] : Compoent&#125; <span class="comment">// 命名视图组件--暂时不知道有什么用</span></span><br><span class="line">    <span class="number">5.</span> redirect? : string | Location | <span class="built_in">Function</span> <span class="comment">// 重定向 -- 修改路由有别与alias</span></span><br><span class="line">    <span class="number">6.</span> props? : boolean | <span class="built_in">Object</span> | <span class="built_in">Function</span> <span class="comment">// 一般通过path/test2/:id来匹配路由信息</span></span><br><span class="line">    <span class="number">7.</span> alias? : string | <span class="built_in">Array</span>&lt;string&gt; <span class="comment">// 别名</span></span><br><span class="line">      	-- a组件的别名是/b， 意味着，当用户访问路由/b的时候，url显示/b，但是路由实际匹配a组件内容</span><br><span class="line">    <span class="number">8.</span> children ? : <span class="built_in">Array</span>&lt;routeConfig&gt; <span class="comment">// 嵌套路由</span></span><br><span class="line">    <span class="number">9.</span> beforeEnter <span class="comment">// 路由独享守卫</span></span><br><span class="line">    <span class="number">10</span> meta ? : any <span class="comment">// 设置元信息 通过$route.matched来获取 </span></span><br><span class="line">      	-- <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;&#125;</span><br><span class="line">    		<span class="number">2.6</span>+以后版本更新了下面<span class="number">2</span>个config</span><br><span class="line">    <span class="number">11</span> caseSensitive? : boolean <span class="comment">// 匹配规则是否大小写敏感（默认：false）</span></span><br><span class="line">    <span class="number">12</span> pathToRegexpOptions ? : <span class="built_in">Object</span>  <span class="comment">//编译正则的选项</span></span><br></pre></td></tr></table></figure>
<h1 id="路由对象的属性"><a href="#路由对象的属性" class="headerlink" title="路由对象的属性"></a>路由对象的属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$route.path: string <span class="comment">// 绝对路径</span></span><br><span class="line">$route.params: <span class="built_in">Object</span> <span class="comment">// 包含动态片段和全匹配片段</span></span><br><span class="line">$route.query : <span class="built_in">Object</span> <span class="comment">// URL查询参数</span></span><br><span class="line">$route.hash : string</span><br><span class="line">$route.fullPath: string</span><br><span class="line">$route.matched： <span class="built_in">Array</span>&lt;routeRecord&gt; <span class="comment">//路由记录--展示路由对象</span></span><br><span class="line">$route.name : <span class="comment">//当前路由的名称</span></span><br><span class="line">$route.redirectedFrom: <span class="comment">//如果存在重定向，即为重定向来源的路由的名字</span></span><br></pre></td></tr></table></figure>
<h1 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h1><p>通过在Vue根实例router配置传入router实例，下面的这些属性成员会被注入到每个子组件里</p>
<ul>
<li>this.$router   ：  router实例–常见操作this.$touer.push()</li>
<li>this.$route： 当前激活的路由信息对象，这个属性是只读的，属性看上面的内容↑</li>
</ul>
<h1 id="组件内部的配置选项"><a href="#组件内部的配置选项" class="headerlink" title="组件内部的配置选项"></a>组件内部的配置选项</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">  <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">   next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">  	<span class="comment">// 可以通过 `vm` 访问组件实例</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 在当前路由改变，但是该组件被复用时调用 2.2新增</span></span><br><span class="line">  <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">  <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="导航解析流程"><a href="#导航解析流程" class="headerlink" title="导航解析流程"></a>导航解析流程</h1><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css小知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/23/css小知识/" class="article-date">
      <time datetime="2019-05-23T11:34:10.956Z" itemprop="datePublished">2019-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/css小知识/">css小知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>1.长名称或词组可以使用中横线来为选择器命名。<br>2.不建议使用“_”下划线来命名CSS选择器。</p>
<p>​            输入的时候少按一个shift键;<br>　        浏览器兼容问题 (比如使用<em>tips的选择器命名，在IE6是无效的)<br>　        能良好区分JavaScript变量命名(JS变量命名是用“</em>”)</p>
<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>​    高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</p>
<p>​    行内元素只能容纳文本或则其他行内元素。（a特殊）</p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>只有 文字才 能组成段落  因此 p  里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</p>
<p>inline-block</p>
<p>​    在行内元素中有几个特殊的标签——<img>、<input>、<td>，可以对它们设置宽高和对齐属性，有些资料可能会称                  它们为行内块元素。</td></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack打包公共代码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/13/webpack打包公共代码/" class="article-date">
      <time datetime="2019-03-13T13:57:09.013Z" itemprop="datePublished">2019-03-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/webpack打包公共代码/">webpack打包公共代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="注意，本文档基于webpack-3-1-0"><a href="#注意，本文档基于webpack-3-1-0" class="headerlink" title="注意，本文档基于webpack@3.1.0"></a>注意，本文档基于<a href="mailto:webpack@3.1.0" target="_blank" rel="noopener">webpack@3.1.0</a></h1><p>webpack不会对单页面进行公共代码的打包，所以需要多entry</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'pageA'</span>: <span class="string">'./src/pageA'</span>,</span><br><span class="line">    <span class="string">'pageB'</span>: <span class="string">'./src/pageB'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].chunk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      minChunks: <span class="number">2</span>   出现次数判断是否打包到common.js里面</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pageA.js</span><br><span class="line">import &apos;./subPageA&apos;</span><br><span class="line">import &apos;./subPageB&apos;</span><br><span class="line">export default &apos;PageA&apos;</span><br><span class="line"></span><br><span class="line">pageB.js</span><br><span class="line">import &apos;./subPageA&apos;</span><br><span class="line">import &apos;./subPageB&apos;</span><br><span class="line">export default &apos;PageB&apos;</span><br><span class="line"></span><br><span class="line">subpageA.js</span><br><span class="line">import * as modulesA from &apos;./moduleA&apos;</span><br><span class="line">export default function Fun() &#123;</span><br><span class="line">  console.log(&apos;subpageA&apos;)</span><br><span class="line">  modulesA(&apos;subpageA的输出&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subpageB.js</span><br><span class="line">import * as modulesA from &apos;./moduleA&apos;</span><br><span class="line">export default function FunB() &#123;</span><br><span class="line">  console.log(&apos;subpageB&apos;)</span><br><span class="line">  modulesA(&apos;subpageB的输出&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modulesA.js</span><br><span class="line">export default function modules(data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过查看打包后的pageA/B包的大小判定是否打包成功，打包成功后的pageA/B里面没有subpageA/B/modulesA的代码在里面</span><br></pre></td></tr></table></figure>
<h1 id="打包第三方和公共方法"><a href="#打包第三方和公共方法" class="headerlink" title="打包第三方和公共方法"></a>打包第三方和公共方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'pageA'</span>: <span class="string">'./src/pageA'</span>,</span><br><span class="line">    <span class="string">'pageB'</span>: <span class="string">'./src/pageB'</span>,</span><br><span class="line">    <span class="string">'vendor'</span>: [<span class="string">'lodash'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].chunk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      chunks: [<span class="string">'pageA'</span>, <span class="string">'pageB'</span>] <span class="comment">//这里需要自己写入口文件，因为判定了entry入口,否则报错</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">'vendor'</span>,<span class="string">'manifest'</span>], <span class="comment">//第三方的包，和webpack自己生成的文件</span></span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack处理css" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/13/webpack处理css/" class="article-date">
      <time datetime="2019-03-13T13:57:08.997Z" itemprop="datePublished">2019-03-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/webpack处理css/">webpack处理css</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>下载依赖包<br>style-loader css-loader –save-dev</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">file-loader --save-dev</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'./dist/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// loader: 'style-loader'</span></span><br><span class="line">            loader: <span class="string">'style-loader/url'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// loader: 'css-loader'</span></span><br><span class="line">            loader: <span class="string">'file-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;</span><br><span class="line">使用file-loader 是往页面中插入link标签， 比较小众的功能</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2021 Ken
                个人总结
            </div>
            <div class="footer-right">
                <span id="busuanzi_container_site_pv">
                    本站总访问量<span id="busuanzi_value_site_pv"></span>次
                </span>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <script type="text/Javascript"> document.onselectstart=function(e){return false;}; </script>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
            
            
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
  <script type="text/javascript" color="234,11,90" opacity='1' src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>